<!DOCTYPE html>
<html lang="zh">
<head>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-512.png">
<meta name="theme-color" content="#000000">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Retro Cam Ultimate</title>
<style>
    :root {
        --leather-color: #181818;
        --metal-grad: linear-gradient(to bottom, #f0f0f0 0%, #d0d0d0 15%, #b0b0b0 40%, #8a8a8a 100%);
        --shutter-grey: linear-gradient(to bottom, #e0e0e0, #999);
    }

    * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { margin: 0; padding: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; overflow: hidden; font-family: 'Arial', sans-serif; color: #333; perspective: 1200px; }

    /* 全屏提示與轉向鎖定 */
    #fullscreen-prompt, #orientation-lock { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; text-align: center; }
    #orientation-lock { display: none; background: #111; z-index: 9999; }
    #enter-fs-btn { padding: 15px 30px; background: #c00; color: white; border: 1px solid #fff; font-family: 'Courier New', monospace; font-size: 18px; cursor: pointer; animation: pulseBtn 2s infinite; margin-top: 20px; }
    @keyframes pulseBtn { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }
    #orientation-lock svg { width: 60px; height: 60px; fill: #fff; animation: rotatePhone 2s infinite; }
    @keyframes rotatePhone { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } }

    /* 相機容器 - [修改] 增加邊緣光 drop-shadow 以區分黑色背景 */
    #camera-container {
        width: 760px; height: 420px; position: relative; transform-origin: center;
        /* 第一層 shadow 是微弱白光(輪廓光)，第二層是原本的投影 */
        filter: drop-shadow(0 0 1px rgba(255,255,255,0.3)) drop-shadow(0 30px 60px rgba(0,0,0,0.9)); 
        display: none;
        transform-style: preserve-3d; 
    }

    .top-plate {
        width: 100%; height: 110px; background: var(--metal-grad);
        border-radius: 12px 12px 2px 2px; position: relative; z-index: 10;
        /* [修改] 增加頂蓋邊框清晰度 */
        border: 1px solid rgba(255,255,255,0.3);
        border-bottom: 1px solid #555; 
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
    }

    /* 部件樣式 */
    .shutter-release-btn { position: absolute; top: -12px; right: 55px; width: 46px; height: 18px; background: var(--shutter-grey); border-radius: 4px 4px 0 0; border: 1px solid #888; border-bottom: none; cursor: pointer; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), 0 -2px 5px rgba(0,0,0,0.2); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
    .shutter-release-btn.pressed { transform: translateY(8px); transition: transform 0.05s ease-out; }
    
    /* 小取景器 */
    .viewfinder-wrap { 
        position: absolute; top: 15px; left: 30px; width: 120px; height: 80px; 
        background: #111; border: 3px solid #666; border-radius: 4px; 
        box-shadow: 0 2px 5px rgba(0,0,0,0.4); overflow: hidden; cursor: zoom-in; z-index: 12; 
    }
    .vf-glass { width: 100%; height: 100%; opacity: 0.9; display: block; }
    
    .serial-number { position: absolute; top: 65px; left: 165px; font-size: 13px; letter-spacing: 1px; font-weight: bold; color: #555; text-shadow: 0 1px 0 rgba(255,255,255,0.7); font-family: 'Courier New', Courier, monospace; pointer-events: none; z-index: 15; }
    .prism-hump { position: absolute; top: -15px; left: 50%; transform: translateX(-50%); width: 140px; height: 125px; z-index: 11; clip-path: polygon(25% 0%, 75% 0%, 100% 100%, 0% 100%); background: linear-gradient(to bottom, #d0d0d0 0%, #b0b0b0 50%, #808080 100%); box-shadow: inset 0 0 10px rgba(0,0,0,0.2); display: flex; justify-content: center; }
    .prism-hump::after { content: ''; width: 1px; height: 100%; background: rgba(0,0,0,0.1); }
    .lever-base { position: absolute; top: 35px; right: 100px; width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(#ccc, #999); border: 1px solid #666; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.5); }
    .lever-base.glow { box-shadow: 0 0 15px #ffaa00, inset 0 0 5px #fff; border-color: #ffaa00; animation: glowPulse 1s infinite alternate; }
    @keyframes glowPulse { from { opacity: 0.6; } to { opacity: 1; } }
    .advance-lever { position: absolute; top: 48px; right: 105px; width: 120px; height: 18px; background: linear-gradient(to right, #222, #444); border-radius: 4px; transform-origin: 110px 9px; transform: rotate(10deg); cursor: grab; box-shadow: 2px 2px 4px rgba(0,0,0,0.6); z-index: 6; display: flex; align-items: center; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .lever-grip { width: 30px; height: 24px; background: #111; border-radius: 4px 0 0 4px; margin-left: -2px; box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2); }
    .right-controls { position: absolute; top: 20px; right: 20px; width: 60px; height: 80px; z-index: 15; display: flex; flex-direction: column; align-items: center; }
    .counter-window { width: 36px; height: 24px; background: #111; border: 1px solid #666; border-radius: 2px; margin-bottom: 10px; box-shadow: inset 0 0 5px #000; display: flex; justify-content: center; align-items: center; }
    .counter-digits { color: #ff9900; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; text-shadow: 0 0 2px #ff5500; }
    .mode-switch-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
    .mode-labels { display: flex; gap: 15px; font-size: 10px; font-weight: bold; color: #444; margin-bottom: 2px; font-family: sans-serif; }
    .switch-track { width: 36px; height: 14px; background: #333; border-radius: 10px; position: relative; box-shadow: inset 0 1px 3px #000; }
    .switch-knob { width: 18px; height: 18px; background: radial-gradient(#eee, #999); border-radius: 50%; position: absolute; top: -2px; left: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid #666; transition: left 0.3s; }
    .mode-switch-container.mode-36 .switch-knob { left: 18px; }
    .ready-light { position: absolute; top: 20px; right: 165px; width: 8px; height: 8px; background: #300; border-radius: 50%; box-shadow: inset 0 0 2px #000; transition: background 0.3s; z-index: 15; }
    .ready-light.active { background: #f00; box-shadow: 0 0 8px #f00, inset 0 0 2px #fff; }

    .camera-body {
        width: 100%; height: 310px; position: relative; border-radius: 0 0 8px 8px; 
        perspective: 1000px;
    }

    /* 機背鎖扣 - [修改] 增加邊框 */
    .back-lock {
        position: absolute; top: 40px; right: -12px; width: 12px; height: 40px;
        background: linear-gradient(to bottom, #444, #222);
        border: 1px solid #222; border-left: none; border-radius: 0 4px 4px 0;
        /* 增加邊緣高光 */
        border-top: 1px solid #555; border-bottom: 1px solid #555; border-right: 1px solid #555;
        cursor: pointer; z-index: 20;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
    }
    .back-lock::after { content: ''; width: 4px; height: 20px; background: #111; border-radius: 2px; }
    .back-lock:active { transform: translateX(2px); }

    /* 可翻開的機背 */
    .back-door-wrapper {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        transform-origin: left center; transform-style: preserve-3d;
        transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1); z-index: 5;
    }
    .back-door-wrapper.open { transform: rotateY(-100deg); }

    .back-door-face {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        background-color: var(--leather-color);
        background-image: radial-gradient(rgba(0,0,0,0.4) 15%, transparent 16%), radial-gradient(rgba(255,255,255,0.05) 15%, transparent 16%);
        background-size: 6px 6px; background-position: 0 0, 3px 3px;
        border-radius: 0 0 8px 8px; 
        /* [修改] 增加機身邊框線和內發光，使其從背景中分離 */
        border-left: 1px solid #333;
        border-right: 1px solid #333;
        border-bottom: 1px solid #333;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1), inset 0 0 60px rgba(0,0,0,1);
        backface-visibility: hidden;
    }
    .back-door-interior {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        background: #1a1a1a; border-radius: 0 0 8px 8px; transform: rotateY(180deg);
        backface-visibility: hidden; box-shadow: inset 0 0 20px #000;
        display: flex; justify-content: center; align-items: center;
        border: 1px solid #333; /* 內部也要有邊框 */
    }
    .pressure-plate { width: 90%; height: 80%; background: repeating-linear-gradient(90deg, #222, #222 20px, #111 20px, #111 22px); border: 2px solid #000; box-shadow: inset 0 0 10px #000; }

    /* 相簿 (機身內部) */
    .camera-interior {
        width: 100%; height: 100%; background: #0a0a0a; border-radius: 0 0 8px 8px;
        box-shadow: inset 0 0 40px #000; position: absolute; top: 0; left: 0; z-index: 1;
        display: flex; flex-direction: column; overflow: hidden;
        /* 增加邊框 */
        border-left: 1px solid #333;
        border-right: 1px solid #333;
        border-bottom: 1px solid #333;
    }
    .album-container {
        flex: 1; padding: 20px; overflow-y: auto;
        display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 15px; align-content: flex-start;
    }
    .album-container::-webkit-scrollbar { width: 8px; }
    .album-container::-webkit-scrollbar-track { background: #111; }
    .album-container::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

    .album-photo { position: relative; border: 2px solid #333; cursor: pointer; transition: transform 0.2s, border-color 0.2s; aspect-ratio: 16 / 9; background: #000; }
    .album-photo img { width: 100%; height: 100%; object-fit: contain; display: block; }
    .album-photo.selected { border-color: #c00; transform: scale(0.95); }
    .album-photo.selected::after { content: '✔'; position: absolute; top: 2px; right: 2px; background: #c00; color: white; font-size: 12px; padding: 2px 4px; }
    .album-seq { position: absolute; top: 2px; left: 2px; font-family: 'Courier New'; font-size: 10px; color: #ff9900; background: rgba(0,0,0,0.7); padding: 1px 3px; }

    .album-controls { height: 50px; background: #181818; border-top: 1px solid #333; display: flex; justify-content: flex-end; align-items: center; padding: 0 20px; gap: 15px; }
    .album-btn { background: transparent; border: 1px solid #666; color: #888; font-family: 'Courier New', monospace; padding: 5px 10px; cursor: pointer; font-size: 12px; }
    .album-btn:hover { color: #fff; border-color: #fff; }
    .album-btn.action { border-color: #c00; color: #c00; }
    .album-btn.action:hover { background: #c00; color: #fff; }

    .copyright-mark { position: absolute; bottom: 14px; right: 22px; font-family: 'Arial', sans-serif; font-weight: bold; font-size: 12px; letter-spacing: 0.5px; color: rgba(255, 255, 255, 0.25); text-shadow: -1px -1px 1px rgba(0,0,0,0.9), 1px 1px 0 rgba(255,255,255,0.05); pointer-events: none; z-index: 5; text-transform: uppercase; }
    .film-door { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 120px; border: 4px solid #000; background: #1a1a1a; box-shadow: 0 1px 0 rgba(255,255,255,0.1), inset 0 0 10px #000; border-radius: 2px; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 2; }
    .memo-holder-frame { width: 170px; height: 90px; border: 2px solid #333; position: relative; background: #222; display: flex; justify-content: center; align-items: center; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.8); }
    .film-card { width: 150px; height: 70px; background: #f4e9c5; box-shadow: 1px 1px 4px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; transform: rotate(-1deg); transition: filter 0.3s; }
    .film-card::before, .film-card::after { content: ''; position: absolute; width: 100%; height: 6px; background: #333; transition: background 0.3s ease; }
    .film-card::before { top: 0; } .film-card::after { bottom: 0; }
    .film-card[data-mode="BW"]::before, .film-card[data-mode="BW"]::after { background: #111; }
    .film-card[data-mode="COLOR"]::before, .film-card[data-mode="COLOR"]::after { background: #c00; }
    .film-card[data-mode="CCD"]::before, .film-card[data-mode="CCD"]::after { background: #0055cc; }
    .film-card[data-mode="FILM"]::before, .film-card[data-mode="FILM"]::after { background: #007700; }
    .film-card[data-mode="HCBW"]::before, .film-card[data-mode="HCBW"]::after { background: #555; }
    .film-card h3 { margin: 4px 0 0; font-size: 24px; font-weight: 900; color: #000; line-height: 1; font-family: Impact, sans-serif; }
    .film-card p { margin: 2px 0; font-size: 10px; color: #333; font-weight: bold; text-transform: uppercase; }

    /* 全屏 UI (Viewfinder) */
    #fs-viewfinder { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: #000; z-index: 10000; display: none; cursor: crosshair; 
    }
    #fs-canvas { width: 100%; height: 100%; object-fit: contain; }
    .fs-ui-layer { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        pointer-events: none; box-shadow: inset 0 0 150px rgba(0,0,0,0.7); 
    }
    .fs-guide-frame { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        width: 85%; height: 85%; border: 1px solid rgba(255,255,255,0.3); 
    }
    .split-image-circle { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        width: 60px; height: 60px; border: 1px solid rgba(255,255,255,0.4); 
        border-radius: 50%; 
    }
    .fs-data { 
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
        color: #0f0; font-family: 'Courier New', monospace; font-size: 20px; 
        text-shadow: 0 0 5px #0f0; display: flex; gap: 30px; 
        background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px; 
    }
    #vf-close-btn { 
        position: absolute; top: 20px; left: 20px; pointer-events: auto; 
        color: #fff; font-size: 40px; cursor: pointer; opacity: 0.6; 
        font-family: Arial, sans-serif; line-height: 0.5; 
        text-shadow: 0 0 4px #000; z-index: 10001; 
    }
    #vf-close-btn:hover { opacity: 1; }

    .shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1500; animation: shutterAction 0.15s ease-in-out forwards; }
    .flash-effect { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; opacity: 0.8; animation: flashFade 0.2s ease-out forwards; }
    .vf-shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 20; animation: shutterAction 0.15s ease-in-out forwards; pointer-events: none; }
    .vf-flash-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 21; opacity: 0.8; animation: flashFade 0.2s ease-out forwards; pointer-events: none; }
    @keyframes shutterAction { 0% { opacity: 0; } 10% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
    @keyframes flashFade { from { opacity: 0.8; } to { opacity: 0; } }

    #review-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15,15,15,0.98); z-index: 2000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    #review-img { max-width: 90%; max-height: 70%; border: 10px solid #fff; box-shadow: 0 10px 50px rgba(0,0,0,1); }
    .review-controls { margin-top: 30px; display: flex; gap: 40px; }
    .btn-retro { background: transparent; border: 2px solid #fff; color: #fff; padding: 12px 30px; font-family: 'Courier New', monospace; font-weight: bold; font-size: 18px; cursor: pointer; }
    .btn-retro:active { background: #fff; color: #000; }

    /* 樣式選擇器 */
    #style-selector-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 2500; display: none;
        flex-direction: column; justify-content: center; align-items: center;
    }
    .style-options { display: flex; gap: 20px; margin-top: 20px; }
    .style-btn {
        width: 120px; height: 90px; background: #333; border: 2px solid #666;
        color: #fff; display: flex; justify-content: center; align-items: center;
        cursor: pointer; flex-direction: column; font-family: 'Courier New'; font-size: 12px;
        transition: 0.2s;
    }
    .style-btn:hover { border-color: #c00; color: #c00; }
    .style-preview { width: 60px; height: 40px; background: #111; margin-bottom: 8px; }
    .sp-std { border: none; }
    .sp-white { border: 2px solid white; border-bottom: 4px solid white; background: #333; } 
    .sp-film { border-top: 6px solid black; border-bottom: 6px solid black; background: #333; position: relative; }
    .sp-film::before, .sp-film::after { content: '...'; position: absolute; color: white; font-size: 8px; letter-spacing: 4px; left: 2px; }
    .sp-film::before { top: -8px; } .sp-film::after { bottom: -4px; }

    /* 沖洗動畫 */
    #developing-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .photo-paper-container { transform: scale(0.9); display: flex; justify-content: center; align-items: center; margin-bottom: 30px; }
    
    #dev-image-wrap { 
        box-shadow: 0 0 50px #000; 
        opacity: 0; 
        max-height: 80vh; max-width: 80vw;
        transition: all 0.3s;
    }
    
    .dev-status-text { color: #888; font-family: monospace; font-size: 16px; letter-spacing: 2px; animation: pulse 1s infinite; margin-top: 20px;}
    
    /* 導出選項 */
    #export-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9); z-index: 4000; display: none;
        flex-direction: column; justify-content: center; align-items: center;
    }
    .export-opt-group { margin-top: 20px; display: flex; gap: 20px; }

    /* 放大檢視層 */
    #zoom-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); z-index: 5000; display: none;
        justify-content: center; align-items: center; cursor: zoom-out;
    }
    #zoom-img {
        max-width: 95%; max-height: 95%;
        box-shadow: 0 0 20px #000; object-fit: contain;
        transition: transform 0.3s ease;
    }

    @keyframes pulse { 0%,100% {opacity:0.5} 50% {opacity:1}}
    
    @keyframes developProcess {
        0% { opacity: 0; filter: brightness(0.1) blur(20px) sepia(1) contrast(0.8); transform: scale(0.95); }
        40% { opacity: 0.6; filter: brightness(0.7) blur(5px) sepia(0.6) contrast(0.9); } 
        100% { opacity: 1; filter: none; transform: scale(1); }
    }
</style>
</head>
<body>

    <div id="fullscreen-prompt">
        <p>FULLSCREEN REQUIRED</p>
        <button id="enter-fs-btn">POWER ON</button>
    </div>

    <div id="orientation-lock">
        <svg viewBox="0 0 24 24"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg>
        <p>ROTATE DEVICE</p>
    </div>

    <div id="fs-viewfinder">
        <canvas id="fs-canvas"></canvas>
        <div class="fs-ui-layer">
            <div id="vf-close-btn" title="Exit Viewfinder">×</div>
            <div class="fs-guide-frame"></div>
            <div class="split-image-circle"></div>
            <div class="fs-data">
                <span id="fs-mode-text">B&W</span><span>1/250</span><span>f/2.8</span><span id="fs-counter">36</span>
            </div>
        </div>
    </div>

    <div id="camera-container">
        <div class="top-plate">
            <div class="viewfinder-wrap" id="vfTrigger" title="Live View">
                <canvas class="vf-glass" id="smallCanvas"></canvas>
            </div>
            <div class="serial-number">NO. 854021</div>
            <div class="prism-hump"></div>
            <div class="ready-light" id="readyLight"></div>

            <div class="lever-base" id="leverBase"></div>
            <div class="advance-lever" id="advanceLever">
                <div class="lever-grip"></div>
            </div>

            <div class="shutter-release-btn" id="shutterBtn"></div>

            <div class="right-controls">
                <div class="counter-window">
                    <span class="counter-digits" id="frameCounter">S</span>
                </div>
                <div class="mode-switch-container" id="rollModeSwitch">
                    <div class="mode-labels"><span>1</span><span>36</span></div>
                    <div class="switch-track"><div class="switch-knob"></div></div>
                </div>
            </div>
        </div>

        <div class="camera-body">
            <div class="camera-interior">
                <div class="album-container" id="albumGrid"></div>
                <div class="album-controls">
                    <button class="album-btn" id="alb-sel-all">SELECT ALL</button>
                    <button class="album-btn action" id="alb-delete" style="border-color:#c00; color:#c00;">DELETE</button>
                    <button class="album-btn action" id="alb-download">DOWNLOAD</button>
                    <button class="album-btn action" id="alb-share">SHARE</button>
                </div>
            </div>
            <div class="back-door-wrapper" id="backDoorWrapper">
                <div class="back-door-face">
                    <div class="copyright-mark">Designed by Chan Kwun Kin</div>
                    <div class="film-door" id="filmDoor">
                        <div class="memo-holder-frame">
                            <div class="film-card">
                                <h3 id="modeTitle">B&W</h3>
                                <p id="modeSub">TRI-X 400</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="back-door-interior">
                    <div class="pressure-plate"></div>
                </div>
            </div>
            <div class="back-lock" id="backLock" title="Open Back"></div>
        </div>
    </div>

    <div id="style-selector-overlay">
        <h2 style="color:white; font-family:'Courier New'; text-align:center;">SELECT PRINT STYLE</h2>
        <div class="style-options">
            <div class="style-btn" data-style="standard">
                <div class="style-preview sp-std"></div>
                STANDARD
            </div>
            <div class="style-btn" data-style="white">
                <div class="style-preview sp-white"></div>
                INSTANT
            </div>
            <div class="style-btn" data-style="film">
                <div class="style-preview sp-film"></div>
                FILM
            </div>
        </div>
    </div>

    <div id="review-overlay">
        <img id="review-img" src="" alt="Review">
        <div class="review-controls">
            <button class="btn-retro" id="btn-discard">DISCARD</button>
            <button class="btn-retro" id="btn-keep">KEEP</button>
        </div>
    </div>

    <div id="developing-overlay">
        <div class="photo-paper-container">
            <img id="dev-image-wrap" src="" alt="Developing">
        </div>
        <div class="dev-status-text" id="devStatus">DEVELOPING...</div>
    </div>
    
    <div id="zoom-overlay">
        <img id="zoom-img" src="" alt="Zoomed Photo">
    </div>

    <div id="export-modal">
        <h2 style="color:#c00; font-family:'Courier New'">EXPORT OPTIONS</h2>
        <p style="color:#fff; font-family:sans-serif">Include Serial Number?</p>
        <div class="export-opt-group">
            <button class="btn-retro" id="exp-no-serial">NO SERIAL</button>
            <button class="btn-retro" id="exp-with-serial" style="border-color:#c00; color:#c00">WITH SERIAL</button>
        </div>
        <button class="btn-retro" id="exp-cancel" style="margin-top:30px; border:none; opacity:0.5">CANCEL</button>
    </div>

    <video id="video-source" autoplay playsinline style="display:none"></video>
    <canvas id="process-canvas" style="display:none"></canvas>
    <canvas id="final-canvas" style="display:none"></canvas>

    <script>
        const DB_NAME = "RetroCamDB_ProMax";
        const TEMP_STORE = "temp_roll"; 
        const ALBUM_STORE = "user_album";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 3);
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(TEMP_STORE)) { db.createObjectStore(TEMP_STORE, { autoIncrement: true }); }
                    if (!db.objectStoreNames.contains(ALBUM_STORE)) { db.createObjectStore(ALBUM_STORE, { keyPath: "id", autoIncrement: true }); }
                };
                request.onsuccess = (e) => { db = e.target.result; resolve(db); };
                request.onerror = () => reject("DB Error");
            });
        }

        function saveToTemp(dataUrl) {
            return new Promise((resolve) => {
                const tx = db.transaction([TEMP_STORE], "readwrite");
                tx.objectStore(TEMP_STORE).add({ image: dataUrl, date: new Date() }).onsuccess = () => resolve(true);
            });
        }
        
        function getTempCount() {
            return new Promise((resolve) => {
                const tx = db.transaction([TEMP_STORE], "readonly");
                tx.objectStore(TEMP_STORE).count().onsuccess = (e) => resolve(e.target.result);
            });
        }

        function getTempPhotos() {
            return new Promise((resolve) => {
                const tx = db.transaction([TEMP_STORE], "readonly");
                tx.objectStore(TEMP_STORE).getAll().onsuccess = (e) => resolve(e.target.result);
            });
        }

        function clearTemp() {
            return new Promise(resolve => {
                db.transaction([TEMP_STORE], "readwrite").objectStore(TEMP_STORE).clear().onsuccess = resolve;
            });
        }

        function saveToAlbum(processedImage, serialNumber, styleInfo) {
            return new Promise(resolve => {
                const tx = db.transaction([ALBUM_STORE], "readwrite");
                tx.objectStore(ALBUM_STORE).add({ 
                    image: processedImage, 
                    timestamp: Date.now(),
                    serial: serialNumber,
                    style: styleInfo 
                }).onsuccess = resolve;
            });
        }

        function getAlbumPhotos() {
            return new Promise(resolve => {
                const tx = db.transaction([ALBUM_STORE], "readonly");
                tx.objectStore(ALBUM_STORE).getAll().onsuccess = (e) => resolve(e.target.result);
            });
        }

        function deleteFromAlbum(ids) {
            return new Promise(resolve => {
                const tx = db.transaction([ALBUM_STORE], "readwrite");
                const store = tx.objectStore(ALBUM_STORE);
                ids.forEach(id => store.delete(id));
                tx.oncomplete = resolve;
            });
        }

        let isRollMode = localStorage.getItem('rollMode') === 'true';
        let currentFrame = 0;
        let pendingPhoto = null;
        let globalSerialCounter = parseInt(localStorage.getItem('global_serial_counter') || '1');

        const MODES = [
            { id: 'BW', name: 'B&W', sub: 'TRI-X 400', type: 'bw' },
            { id: 'COLOR', name: 'COLOR', sub: 'GAME-CAM', type: 'color' },
            { id: 'CCD', name: 'DIGI', sub: 'CCD SENSOR', type: 'ccd' },
            { id: 'FILM', name: 'FILM', sub: 'JPN-CYAN', type: 'film' },
            { id: 'HCBW', name: 'HC-BW', sub: 'ACROS 100', type: 'hcbw' }
        ];
        
        let savedMode = localStorage.getItem('camModeIdx');
        let currentModeIdx = savedMode ? parseInt(savedMode) : 0;
        if(currentModeIdx < 0 || currentModeIdx >= MODES.length) currentModeIdx = 0;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const actx = new AudioContext();

        function playShutterSound() {
            if (actx.state === 'suspended') actx.resume();
            const t = actx.currentTime;
            const osc = actx.createOscillator(); const gain = actx.createGain();
            osc.type = 'square'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.05);
            gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
            osc.connect(gain); gain.connect(actx.destination); osc.start(t); osc.stop(t + 0.06);
            const bufferSize = actx.sampleRate * 0.1; 
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
            const noise = actx.createBufferSource(); noise.buffer = buffer;
            const noiseFilter = actx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 1000;
            const noiseGain = actx.createGain(); noiseGain.gain.setValueAtTime(0.8, t); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(actx.destination); noise.start(t);
        }
        function playLeverSound() {
            if (actx.state === 'suspended') actx.resume();
            const t = actx.currentTime;
            for(let i=0; i<5; i++) {
                const osc = actx.createOscillator(); const gain = actx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t + i*0.06); osc.frequency.exponentialRampToValueAtTime(100, t + i*0.06 + 0.03);
                gain.gain.setValueAtTime(0.1, t + i*0.06); gain.gain.exponentialRampToValueAtTime(0.01, t + i*0.06 + 0.03);
                osc.connect(gain); gain.connect(actx.destination); osc.start(t + i*0.06); osc.stop(t + i*0.06 + 0.04);
            }
        }

        const video = document.getElementById('video-source');
        const smallCanvas = document.getElementById('smallCanvas');
        const smallCtx = smallCanvas.getContext('2d', { alpha: false });
        const fsCanvas = document.getElementById('fs-canvas');
        const fsCtx = fsCanvas.getContext('2d', { alpha: false });
        const processCanvas = document.getElementById('process-canvas');
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });
        const finalCanvas = document.getElementById('final-canvas');
        const finalCtx = finalCanvas.getContext('2d');
        
        const rollModeSwitch = document.getElementById('rollModeSwitch');
        const frameCounterUI = document.getElementById('frameCounter');
        const fsCounter = document.getElementById('fs-counter');
        const readyLight = document.getElementById('readyLight');
        const leverBase = document.getElementById('leverBase');
        const advanceLever = document.getElementById('advanceLever');
        const shutterBtn = document.getElementById('shutterBtn');
        
        const vfTrigger = document.getElementById('vfTrigger');
        const fsViewfinder = document.getElementById('fs-viewfinder');
        const vfCloseBtn = document.getElementById('vf-close-btn');

        const backLock = document.getElementById('backLock');
        const backDoorWrapper = document.getElementById('backDoorWrapper');
        const albumGrid = document.getElementById('albumGrid');
        const styleOverlay = document.getElementById('style-selector-overlay');
        const devOverlay = document.getElementById('developing-overlay');
        const devImageWrap = document.getElementById('dev-image-wrap');
        const devStatus = document.getElementById('devStatus');
        const filmCard = document.querySelector('.film-card');
        const modeTitle = document.getElementById('modeTitle');
        const modeSub = document.getElementById('modeSub');
        const fsPrompt = document.getElementById('fullscreen-prompt');
        
        const zoomOverlay = document.getElementById('zoom-overlay');
        const zoomImg = document.getElementById('zoom-img');

        function updateModeUI() {
            const m = MODES[currentModeIdx];
            modeTitle.textContent = m.name; modeSub.textContent = m.sub; 
            document.getElementById('fs-mode-text').textContent = m.name;
            filmCard.setAttribute('data-mode', m.id);
            const h3 = filmCard.querySelector('h3');
            if(m.id === 'BW') h3.style.color = '#000'; 
            else if(m.id === 'FILM') h3.style.color = '#007700';
            else if(m.id === 'COLOR') h3.style.color = '#c00';
            else if(m.id === 'HCBW') h3.style.color = '#333';
            else h3.style.color = '#0055cc';
        }
        updateModeUI();

        async function initSystem() {
            await initDB();
            if (isRollMode) {
                rollModeSwitch.classList.add('mode-36');
                currentFrame = await getTempCount();
            } else {
                rollModeSwitch.classList.remove('mode-36');
                currentFrame = 0;
            }
            checkLeverState();
            updateCounterDisplay();
        }

        function updateCounterDisplay() {
            if (!isRollMode) {
                frameCounterUI.textContent = "S"; fsCounter.textContent = "1";
            } else {
                if (currentFrame === 0) frameCounterUI.textContent = "S";
                else if (currentFrame >= 36) frameCounterUI.textContent = "E";
                else frameCounterUI.textContent = currentFrame;
                fsCounter.textContent = (36 - currentFrame) + " LEFT";
            }
        }

        function checkLeverState() {
            if ((isRollMode && currentFrame >= 36) || (!isRollMode && pendingPhoto)) {
                readyLight.classList.add('active'); leverBase.classList.add('glow');
            } else {
                readyLight.classList.remove('active'); leverBase.classList.remove('glow');
            }
        }

        document.getElementById('enter-fs-btn').addEventListener('click', () => {
            startFullscreenAndCamera();
        });

        function startFullscreenAndCamera() {
            const el = document.documentElement;
            const rfs = el.requestFullscreen || el.webkitRequestFullScreen;
            if (rfs) {
                rfs.call(el).then(() => {
                    initSystem().then(initCamera);
                }).catch(() => {
                    initSystem().then(initCamera);
                });
            }
        }

        async function initCamera() {
            try {
                if(video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false });
                video.srcObject = stream;
                video.onloadedmetadata = () => { 
                    video.play(); 
                    // [修復] 確保權限獲取後，更新界面狀態
                    checkOrientation();
                    renderLoop(); 
                };
            } catch (err) { console.error("Camera Error", err); }
        }

        function enforceFullscreen() {
            if (!document.fullscreenElement) {
                fsPrompt.style.display = 'flex';
                document.getElementById('camera-container').style.display = 'none';
                fsViewfinder.style.display = 'none';
            }
        }

        document.addEventListener('fullscreenchange', enforceFullscreen);
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                enforceFullscreen();
                if(video.srcObject && video.paused) video.play();
            }
        });

        function renderLoop() {
            if (!video.srcObject || !video.srcObject.active || video.paused) return;
            requestAnimationFrame(renderLoop);

            const mode = MODES[currentModeIdx];
            const w = (mode.id === 'BW' || mode.id === 'COLOR') ? 160 : 480;
            const h = (mode.id === 'BW' || mode.id === 'COLOR') ? 90 : 270;

            if (processCanvas.width !== w) { processCanvas.width = w; processCanvas.height = h; }
            processCtx.drawImage(video, 0, 0, w, h);
            
            let imgData = processCtx.getImageData(0, 0, w, h);
            let data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i], g = data[i+1], b = data[i+2];
                if (mode.id === 'FILM') {
                    if (r < 50) r *= 0.8; if (g < 50) g *= 0.8; if (b < 50) b *= 0.8;
                    r = r * 0.92; g = g * 1.02; b = b * 1.08; if (r > 200) r = 200 + (r-200)*0.5;
                    let grain = (Math.random() - 0.5) * 35; 
                    data[i] = r + grain; data[i+1] = g + grain; data[i+2] = b + grain;
                } else if (mode.id === 'BW') {
                    let gray = r * 0.3 + g * 0.59 + b * 0.11; gray = gray > 110 ? gray * 1.25 : gray * 0.7;
                    let noise = (Math.random() - 0.5) * 30; let final = Math.min(255, Math.max(0, gray + noise));
                    data[i] = data[i+1] = data[i+2] = final;
                } else if (mode.id === 'COLOR') {
                    data[i] = Math.floor(r / 42) * 42; data[i+1] = Math.floor(g / 42) * 42; data[i+2] = Math.floor(b / 42) * 42;
                } else if (mode.id === 'CCD') {
                    r = r * 1.02; b = b * 1.08; if (r > 240 || g > 240 || b > 240) { r = 255; g = 250; b = 255; }
                } else if (mode.id === 'HCBW') {
                    let gray = r * 0.299 + g * 0.587 + b * 0.114; gray = 128 + (gray - 128) * 1.5;
                    if(gray < 0) gray = 0; if(gray > 255) gray = 255;
                    data[i] = data[i+1] = data[i+2] = gray;
                }
            }
            processCtx.putImageData(imgData, 0, 0);
            
            if (smallCanvas.width !== w) { smallCanvas.width = w; smallCanvas.height = h; }
            smallCanvas.style.imageRendering = (mode.id === 'BW' || mode.id === 'COLOR') ? 'pixelated' : 'auto';
            smallCtx.drawImage(processCanvas, 0, 0);

            if (fsViewfinder.style.display === 'block') {
                if (fsCanvas.width !== w) { fsCanvas.width = w; fsCanvas.height = h; }
                fsCanvas.style.imageRendering = (mode.id === 'BW' || mode.id === 'COLOR') ? 'pixelated' : 'auto';
                fsCtx.drawImage(processCanvas, 0, 0);
            }
        }

        vfTrigger.addEventListener('click', (e) => {
            e.stopPropagation();
            if (video.readyState >= 2) {
                fsViewfinder.style.display = 'block';
            }
        });

        vfCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            fsViewfinder.style.display = 'none';
        });

        shutterBtn.addEventListener('click', handleShutter);
        fsViewfinder.addEventListener('click', handleShutter);
        
        function handleShutter(e) {
            if(e) e.stopPropagation();
            if (e.target.id === 'vf-close-btn') return;
            if (backDoorWrapper.classList.contains('open')) return;
            if (isRollMode && currentFrame >= 36) return;
            if (!isRollMode && pendingPhoto) return;

            shutterBtn.classList.add('pressed');
            playShutterSound();
            
            const container = (fsViewfinder.style.display === 'block') ? fsViewfinder : vfTrigger;
            const blind = document.createElement('div'); blind.className = container === fsViewfinder ? 'shutter-blind' : 'vf-shutter-blind';
            container.appendChild(blind); setTimeout(() => blind.remove(), 150);
            
            setTimeout(() => {
                performCapture();
                shutterBtn.classList.remove('pressed');
            }, 150);
        }

        async function performCapture() {
            const mode = MODES[currentModeIdx];
            const targetW = 1920, targetH = 1080;
            finalCanvas.width = targetW; finalCanvas.height = targetH;
            finalCtx.filter = 'none'; finalCtx.globalCompositeOperation = 'source-over';

            if (mode.id === 'FILM') {
                finalCtx.imageSmoothingEnabled = true; finalCtx.drawImage(processCanvas, 0, 0, targetW, targetH);
                finalCtx.globalCompositeOperation = 'screen'; finalCtx.filter = 'blur(10px) opacity(0.4)';
                finalCtx.drawImage(processCanvas, 0, 0, targetW, targetH); 
                finalCtx.filter = 'none'; 
                const isLeft = Math.random() > 0.5; const leakW = targetW * (0.3 + Math.random() * 0.4);
                const leakGrad = finalCtx.createLinearGradient(isLeft ? 0 : targetW, 0, isLeft ? leakW : targetW - leakW, 0);
                leakGrad.addColorStop(0, 'rgba(255, 60, 20, 0.6)'); leakGrad.addColorStop(0.4, 'rgba(255, 180, 50, 0.3)'); leakGrad.addColorStop(1, 'rgba(0,0,0,0)');
                finalCtx.fillStyle = leakGrad; finalCtx.fillRect(0, 0, targetW, targetH);
                finalCtx.globalAlpha = 1.0; finalCtx.globalCompositeOperation = 'source-over';
            } else if (mode.id === 'HCBW') {
                finalCtx.imageSmoothingEnabled = true; finalCtx.filter = 'grayscale(100%) contrast(140%)'; finalCtx.drawImage(video, 0, 0, targetW, targetH);
            } else if (mode.id === 'CCD') {
                finalCtx.imageSmoothingEnabled = true; finalCtx.filter = 'blur(1px) contrast(1.1)'; finalCtx.drawImage(processCanvas, 0, 0, targetW, targetH);
            } else {
                finalCtx.imageSmoothingEnabled = false; finalCtx.drawImage(processCanvas, 0, 0, targetW, targetH);
            }

            const highRes = finalCanvas.toDataURL('image/jpeg', 0.92);

            if (isRollMode) {
                await saveToTemp(highRes);
                currentFrame++;
                updateCounterDisplay();
                checkLeverState();
            } else {
                pendingPhoto = highRes;
                document.getElementById('review-img').src = highRes;
                document.getElementById('review-overlay').style.display = 'flex';
                fsViewfinder.style.display = 'none';
            }
        }

        document.getElementById('btn-discard').addEventListener('click', () => { pendingPhoto = null; document.getElementById('review-overlay').style.display = 'none'; });
        document.getElementById('btn-keep').addEventListener('click', () => { 
            document.getElementById('review-overlay').style.display = 'none';
            checkLeverState(); 
        });

        document.getElementById('filmDoor').addEventListener('click', () => {
            if (backDoorWrapper.classList.contains('open')) return;
            currentModeIdx = (currentModeIdx + 1) % MODES.length;
            localStorage.setItem('camModeIdx', currentModeIdx);
            filmCard.style.filter = 'blur(5px)';
            setTimeout(() => { updateModeUI(); filmCard.style.filter = 'none'; }, 200);
        });
        
        rollModeSwitch.addEventListener('click', async () => {
            if(pendingPhoto || (isRollMode && currentFrame > 0 && currentFrame < 36)) {
                if(!confirm("Switching modes will clear current roll. Continue?")) return;
                await clearTemp();
                pendingPhoto = null;
            }
            isRollMode = !isRollMode;
            localStorage.setItem('rollMode', isRollMode);
            rollModeSwitch.classList.toggle('mode-36', isRollMode);
            currentFrame = 0; updateCounterDisplay(); checkLeverState();
        });

        let leverPulled = false;
        advanceLever.addEventListener('click', async () => {
            if (!readyLight.classList.contains('active') || leverPulled) return;
            playLeverSound();
            leverPulled = true;
            advanceLever.style.transform = 'rotate(130deg)';
            
            setTimeout(() => {
                advanceLever.style.transform = 'rotate(10deg)';
                styleOverlay.style.display = 'flex';
                leverPulled = false; 
            }, 400);
        });

        document.querySelectorAll('.style-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const style = e.currentTarget.dataset.style;
                styleOverlay.style.display = 'none';
                readyLight.classList.remove('active');
                leverBase.classList.remove('glow');
                
                let photosToProcess = [];
                if (isRollMode) {
                    photosToProcess = await getTempPhotos();
                } else if (pendingPhoto) {
                    photosToProcess = [{ image: pendingPhoto, date: new Date() }];
                }

                if(photosToProcess.length > 0) {
                    await startDevelopingAnimation(photosToProcess, style);
                }
            });
        });

        function applyFrameAndDate(imgUrl, dateObj, style) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    let w = 1920, h = 1080;
                    let padTop = 0, padSide = 0, padBottom = 0;

                    if (style === 'white') {
                        padTop = 50; padSide = 50; padBottom = 150;
                        w = 1200; 
                        h = Math.floor(w * (9/16)) + padTop + padBottom; 
                    } else if (style === 'film') {
                        padTop = 80; padSide = 0; padBottom = 80;
                    }

                    finalCanvas.width = w; finalCanvas.height = h;
                    const ctx = finalCanvas.getContext('2d');
                    ctx.filter = 'none';

                    if (style === 'white') {
                        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
                        ctx.drawImage(img, padSide, padTop, w - padSide*2, h - padTop - padBottom);
                    } else if (style === 'film') {
                        ctx.drawImage(img, 0, padTop, w, h - padTop*2);
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0, 0, w, padTop);
                        ctx.fillRect(0, h - padBottom, w, padBottom);
                        ctx.fillStyle = '#fff';
                        const holeW = 30, gap = 20;
                        for(let x = 30; x < w; x += (holeW + gap)) {
                            ctx.fillRect(x, 20, holeW, 40);
                            ctx.fillRect(x, h - 60, holeW, 40);
                        }
                    } else {
                        ctx.drawImage(img, 0, 0, w, h);
                    }

                    const d = new Date(dateObj);
                    const dateStr = `'${d.getFullYear().toString().slice(-2)} ${(d.getMonth()+1).toString().padStart(2,'0')} ${d.getDate().toString().padStart(2,'0')}`;
                    
                    ctx.shadowColor = '#ff5500'; ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(255, 170, 50, 0.9)';
                    const fontSize = style === 'white' ? 40 : 50;
                    ctx.font = `bold ${fontSize}px "Courier New", monospace`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                    
                    let dateX, dateY;
                    if (style === 'white') {
                        dateX = w - padSide - 30; 
                        dateY = h - padBottom - 30;
                    } else if (style === 'film') {
                        dateX = w - 50;
                        dateY = h - padBottom - 30;
                    } else {
                        dateX = w - 60;
                        dateY = h - 50;
                    }
                    ctx.fillText(dateStr, dateX, dateY);

                    resolve(finalCanvas.toDataURL('image/jpeg', 0.9));
                };
                img.src = imgUrl;
            });
        }

        function overlaySerial(imgUrl, serialNo, style) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    finalCanvas.width = img.width; finalCanvas.height = img.height;
                    const ctx = finalCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    let x = 30, y = 30, color = '#fff';
                    
                    if (style === 'white') {
                        x = 50; 
                        y = img.height - 80; 
                        color = '#333'; 
                    } else if (style === 'film') {
                        x = 40;
                        y = 100; 
                        color = 'rgba(255,255,255,0.8)';
                    } else {
                        x = 30; y = 30; color = 'rgba(255,255,255,0.8)';
                    }
                    
                    ctx.shadowColor = style === 'white' ? 'transparent' : '#000'; 
                    ctx.shadowBlur = 2;
                    ctx.fillStyle = color;
                    ctx.font = `bold 36px "Courier New", monospace`;
                    ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                    
                    ctx.fillText(`No.${serialNo}`, x, y);
                    
                    resolve(finalCanvas.toDataURL('image/jpeg', 0.9));
                };
                img.src = imgUrl;
            });
        }

        async function startDevelopingAnimation(photos, style) {
            devOverlay.style.display = 'flex';
            devStatus.textContent = "PREPARING...";
            
            const processed = [];
            for (let p of photos) {
                const thisSerial = globalSerialCounter++;
                localStorage.setItem('global_serial_counter', globalSerialCounter);
                const finalImg = await applyFrameAndDate(p.image, p.date, style);
                processed.push({ img: finalImg, serial: thisSerial, style: style });
            }

            for (let i = 0; i < processed.length; i++) {
                devStatus.textContent = `DEVELOPING ${i+1}/${processed.length}`;
                devImageWrap.src = processed[i].img;
                devImageWrap.style.border = style === 'white' ? 'none' : '8px solid white';
                
                devImageWrap.style.animation = 'none';
                devImageWrap.offsetHeight; 
                devImageWrap.style.animation = 'developProcess 3s forwards';
                
                await new Promise(r => setTimeout(r, 3200));
                await saveToAlbum(processed[i].img, processed[i].serial, processed[i].style);
            }

            devStatus.textContent = "FINISHED";
            await new Promise(r => setTimeout(r, 800));
            
            devOverlay.style.display = 'none';
            if (isRollMode) {
                await clearTemp();
                currentFrame = 0;
                updateCounterDisplay();
            } else {
                pendingPhoto = null;
            }
            checkLeverState();
        }

        backLock.addEventListener('click', () => {
            const isOpen = backDoorWrapper.classList.contains('open');
            if (!isOpen) {
                backDoorWrapper.classList.add('open');
                backLock.style.transform = 'translateX(5px)';
                loadAlbum();
            } else {
                closeBackDoor();
            }
        });

        function closeBackDoor() {
            backDoorWrapper.classList.remove('open');
            backLock.style.transform = 'translateX(0)';
        }

        let selectedAlbumIds = new Set();
        let currentAlbumData = [];

        async function loadAlbum() {
            albumGrid.innerHTML = '';
            selectedAlbumIds.clear();
            currentAlbumData = await getAlbumPhotos();
            currentAlbumData.sort((a,b) => b.timestamp - a.timestamp);

            if(currentAlbumData.length === 0) {
                albumGrid.innerHTML = '<p style="color:#555; width:100%; text-align:center; margin-top:50px; font-family:monospace;">ALBUM EMPTY</p>';
                return;
            }

            currentAlbumData.forEach(p => {
                const div = document.createElement('div');
                div.className = 'album-photo';
                div.dataset.id = p.id;
                const img = document.createElement('img');
                img.src = p.image;
                const seq = document.createElement('div');
                seq.className = 'album-seq';
                seq.textContent = `No.${p.serial}`;
                div.appendChild(img);
                div.appendChild(seq);
                
                div.onclick = (e) => {
                    if (div.clickTimeout) {
                        clearTimeout(div.clickTimeout);
                        div.clickTimeout = null;
                        showZoom(p.image);
                    } else {
                        div.clickTimeout = setTimeout(() => {
                            div.clickTimeout = null;
                            toggleSelection(div, p.id);
                        }, 250);
                    }
                };
                
                albumGrid.appendChild(div);
            });
        }
        
        function showZoom(imgSrc) {
            zoomImg.src = imgSrc;
            zoomOverlay.style.display = 'flex';
        }
        
        zoomOverlay.addEventListener('click', () => {
            zoomOverlay.style.display = 'none';
        });

        function toggleSelection(el, id) {
            if (selectedAlbumIds.has(id)) { selectedAlbumIds.delete(id); el.classList.remove('selected'); } 
            else { selectedAlbumIds.add(id); el.classList.add('selected'); }
        }

        document.getElementById('alb-sel-all').addEventListener('click', () => {
            const allEls = document.querySelectorAll('.album-photo');
            const allSelected = selectedAlbumIds.size === currentAlbumData.length;
            allEls.forEach(el => {
                const id = parseInt(el.dataset.id);
                if (allSelected) { selectedAlbumIds.delete(id); el.classList.remove('selected'); } 
                else { selectedAlbumIds.add(id); el.classList.add('selected'); }
            });
        });

        document.getElementById('alb-delete').addEventListener('click', async () => {
            if (!checkSelection()) return;
            if (confirm("DELETE SELECTED PHOTOS?")) {
                const idsToRemove = Array.from(selectedAlbumIds);
                await deleteFromAlbum(idsToRemove);
                await loadAlbum(); 
            }
        });

        const exportModal = document.getElementById('export-modal');
        let exportActionType = ''; 

        function checkSelection() {
            if (selectedAlbumIds.size === 0) { alert("SELECT PHOTOS FIRST"); return false; }
            return true;
        }

        document.getElementById('alb-download').addEventListener('click', () => {
            if(!checkSelection()) return;
            exportActionType = 'download';
            exportModal.style.display = 'flex';
        });

        document.getElementById('alb-share').addEventListener('click', () => {
            if(!checkSelection()) return;
            if(!navigator.share) { alert("SHARING NOT SUPPORTED"); return; }
            exportActionType = 'share';
            exportModal.style.display = 'flex';
        });

        document.getElementById('exp-cancel').addEventListener('click', () => exportModal.style.display = 'none');
        document.getElementById('exp-no-serial').addEventListener('click', () => processExport(false));
        document.getElementById('exp-with-serial').addEventListener('click', () => processExport(true));

        async function processExport(addSerial) {
            const selectedData = currentAlbumData.filter(p => selectedAlbumIds.has(p.id));
            const filesToShare = [];

            for (let p of selectedData) {
                let finalDataUrl = p.image;
                if (addSerial) {
                    finalDataUrl = await overlaySerial(p.image, p.serial, p.style);
                }
                const fileName = `RETRO_No${p.serial}_${Date.now()}.jpg`;

                if (exportActionType === 'download') {
                    const link = document.createElement('a');
                    link.download = fileName;
                    link.href = finalDataUrl;
                    link.click();
                    await new Promise(r => setTimeout(r, 200));
                } else {
                    const blob = await (await fetch(finalDataUrl)).blob();
                    filesToShare.push(new File([blob], fileName, { type: 'image/jpeg' }));
                }
            }

            if (exportActionType === 'share' && filesToShare.length > 0) {
                try { await navigator.share({ files: filesToShare }); } catch (e) {}
            }

            const idsToRemove = selectedData.map(p => p.id);
            await deleteFromAlbum(idsToRemove);
            resetToCameraUI();
        }

        function resetToCameraUI() {
            exportModal.style.display = 'none'; 
            closeBackDoor(); 
            document.getElementById('review-overlay').style.display = 'none';
            pendingPhoto = null;
            checkLeverState();
        }

        function checkOrientation() {
            if (window.innerHeight > window.innerWidth) { 
                document.getElementById('orientation-lock').style.display = 'flex'; 
                document.getElementById('camera-container').style.display = 'none'; 
                fsPrompt.style.display = 'none'; 
            } else { 
                document.getElementById('orientation-lock').style.display = 'none'; 
                if (document.fullscreenElement) { 
                    document.getElementById('camera-container').style.display = 'block'; 
                    document.getElementById('fullscreen-prompt').style.display = 'none'; 
                    resizeElements(); 
                } else {
                    enforceFullscreen();
                }
            }
        }
        function resizeElements() {
            const scale = Math.min(window.innerWidth / 800, window.innerHeight / 480);
            document.getElementById('camera-container').style.transform = `scale(${scale})`;
        }
        window.addEventListener('resize', () => { checkOrientation(); resizeElements(); });

    </script>
</body>
</html>
