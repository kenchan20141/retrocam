<!DOCTYPE html>
<html lang="zh">
<head>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-512.png">
<meta name="theme-color" content="#000000">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Retro Cam - Fine Sketch Edition</title>
<style>
    :root {
        --leather-color: #151515;
        --metal-grad: linear-gradient(to bottom, #f0f0f0 0%, #d0d0d0 15%, #b0b0b0 40%, #8a8a8a 100%);
        --shutter-grey: linear-gradient(to bottom, #e0e0e0, #999);
    }

    * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { margin: 0; padding: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; overflow: hidden; font-family: 'Arial', sans-serif; color: #333; perspective: 1200px; }

    #fullscreen-prompt, #orientation-lock { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; text-align: center; }
    #orientation-lock { display: none; background: #111; z-index: 9999; }
    #enter-fs-btn { padding: 15px 30px; background: #c00; color: white; border: 1px solid #fff; font-family: 'Courier New', monospace; font-size: 18px; cursor: pointer; animation: pulseBtn 2s infinite; margin-top: 20px; }
    @keyframes pulseBtn { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }
    #orientation-lock svg { width: 60px; height: 60px; fill: #fff; animation: rotatePhone 2s infinite; }
    @keyframes rotatePhone { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } }

    #camera-container {
        width: 760px; height: 420px; position: relative; transform-origin: center;
        filter: drop-shadow(0 0 2px rgba(255,255,255,0.25)) drop-shadow(0 30px 60px rgba(0,0,0,0.9)); 
        display: none; transform-style: preserve-3d; 
    }

    .top-plate {
        width: 100%; height: 110px; background: var(--metal-grad);
        border-radius: 12px 12px 2px 2px; position: relative; z-index: 10;
        border: 1px solid rgba(255,255,255,0.3); border-bottom: 1px solid #555; 
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
    }

    .shutter-release-btn { position: absolute; top: -12px; right: 55px; width: 46px; height: 18px; background: var(--shutter-grey); border-radius: 4px 4px 0 0; border: 1px solid #888; border-bottom: none; cursor: pointer; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.8), 0 -2px 5px rgba(0,0,0,0.2); transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
    .shutter-release-btn.pressed { transform: translateY(8px); transition: transform 0.05s ease-out; }
    
    .viewfinder-wrap { position: absolute; top: 15px; left: 30px; width: 120px; height: 80px; background: #111; border: 3px solid #666; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.4); overflow: hidden; cursor: zoom-in; z-index: 12; transition: opacity 0.3s; }
    .vf-glass { width: 100%; height: 100%; opacity: 0.9; display: block; }
    
    .serial-number { position: absolute; top: 65px; left: 165px; font-size: 13px; letter-spacing: 1px; font-weight: bold; color: #555; text-shadow: 0 1px 0 rgba(255,255,255,0.7); font-family: 'Courier New', Courier, monospace; pointer-events: none; z-index: 15; }
    .prism-hump { position: absolute; top: -15px; left: 50%; transform: translateX(-50%); width: 140px; height: 125px; z-index: 11; clip-path: polygon(25% 0%, 75% 0%, 100% 100%, 0% 100%); background: linear-gradient(to bottom, #d0d0d0 0%, #b0b0b0 50%, #808080 100%); box-shadow: inset 0 0 10px rgba(0,0,0,0.2); display: flex; justify-content: center; }
    .prism-hump::after { content: ''; width: 1px; height: 100%; background: rgba(0,0,0,0.1); }
    
    .lever-base { position: absolute; top: 35px; right: 100px; width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(#ccc, #999); border: 1px solid #666; z-index: 5; box-shadow: inset 0 1px 2px rgba(255,255,255,0.5); }
    .lever-base.glow { box-shadow: 0 0 15px #ffaa00, inset 0 0 5px #fff; border-color: #ffaa00; animation: glowPulse 1s infinite alternate; }
    @keyframes glowPulse { from { opacity: 0.6; } to { opacity: 1; } }
    
    .advance-lever { position: absolute; top: 48px; right: 105px; width: 120px; height: 18px; background: linear-gradient(to right, #222, #444); border-radius: 4px; transform-origin: 110px 9px; transform: rotate(10deg); cursor: grab; box-shadow: 2px 2px 4px rgba(0,0,0,0.6); z-index: 6; display: flex; align-items: center; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .lever-grip { width: 30px; height: 24px; background: #111; border-radius: 4px 0 0 4px; margin-left: -2px; box-shadow: inset 1px 1px 2px rgba(255,255,255,0.2); }
    
    .right-controls { position: absolute; top: 20px; right: 20px; width: 60px; height: 80px; z-index: 15; display: flex; flex-direction: column; align-items: center; }
    .counter-window { width: 36px; height: 24px; background: #111; border: 1px solid #666; border-radius: 2px; margin-bottom: 10px; box-shadow: inset 0 0 5px #000; display: flex; justify-content: center; align-items: center; }
    .counter-digits { color: #ff9900; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; text-shadow: 0 0 2px #ff5500; }
    .mode-switch-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
    .mode-labels { display: flex; gap: 15px; font-size: 10px; font-weight: bold; color: #444; margin-bottom: 2px; font-family: sans-serif; }
    .switch-track { width: 36px; height: 14px; background: #333; border-radius: 10px; position: relative; box-shadow: inset 0 1px 3px #000; }
    .switch-knob { width: 18px; height: 18px; background: radial-gradient(#eee, #999); border-radius: 50%; position: absolute; top: -2px; left: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid #666; transition: left 0.3s; }
    .mode-switch-container.mode-36 .switch-knob { left: 18px; }
    
    /* Sketch Switch Controls */
    .sketch-switch-container { position: absolute; top: 20px; left: 155px; display: flex; flex-direction: column; align-items: center; cursor: pointer; z-index: 20; }
    .sketch-labels { display: flex; gap: 8px; font-size: 9px; font-weight: bold; color: #444; margin-bottom: 2px; font-family: sans-serif; text-shadow: 0 1px 0 rgba(255,255,255,0.5); }
    .sketch-labels .active { color: #000; }
    .sketch-switch-track { width: 44px; height: 12px; background: #333; border-radius: 2px; position: relative; box-shadow: inset 0 1px 3px #000; }
    .sketch-switch-knob { width: 22px; height: 16px; background: repeating-linear-gradient(90deg, #ccc, #ccc 2px, #999 2px, #999 4px); border-radius: 2px; position: absolute; top: -2px; left: 0; box-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid #666; transition: left 0.3s; }
    .sketch-switch-container.mode-sketch .sketch-switch-knob { left: 22px; }

    .ready-light { position: absolute; top: 20px; right: 165px; width: 8px; height: 8px; background: #300; border-radius: 50%; box-shadow: inset 0 0 2px #000; transition: background 0.3s; z-index: 15; }
    .ready-light.active { background: #f00; box-shadow: 0 0 8px #f00, inset 0 0 2px #fff; }

    .front-controls-group { display: none; } 
    
    .front-viewfinder-frame {
        position: absolute; top: 15px; right: 40px; width: 90px; height: 65px;
        background: #111; border: 2px solid #666; border-radius: 3px;
        box-shadow: inset 0 0 5px #000, 0 1px 2px rgba(0,0,0,0.3);
        overflow: hidden; cursor: zoom-in; z-index: 16;
    }
    .front-vf-glass { width: 100%; height: 100%; transform: scaleX(-1); }

    .front-shutter-btn {
        position: absolute; top: -10px; left: 50px; width: 40px; height: 16px;
        background: var(--shutter-grey); border-radius: 3px 3px 0 0;
        border: 1px solid #888; border-bottom: none; cursor: pointer; z-index: 16;
        box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    .front-shutter-btn.pressed { transform: translateY(6px); }

    .cable-release-container {
        position: absolute; top: -100px; left: 0; width: 100%; height: 150%;
        pointer-events: none; z-index: 30;
        overflow: visible;
    }
    
    .cable-plunger-wrapper {
        position: absolute; 
        top: 320px; right: -90px; 
        width: 60px; height: 120px;
        pointer-events: auto; cursor: pointer;
        display: flex; flex-direction: column; align-items: center;
        transform: rotate(-10deg);
    }
    .cable-button-head {
        width: 28px; height: 18px;
        background: radial-gradient(circle at 30% 30%, #ff3333, #aa0000);
        border-radius: 50% 50% 5px 5px;
        border: 1px solid #333; border-bottom: none;
        position: relative; z-index: 3;
        box-shadow: inset 0 2px 3px rgba(255,255,255,0.4);
        transition: transform 0.1s;
    }
    .cable-stem {
        width: 8px; height: 20px;
        background: linear-gradient(to right, #999, #eee, #777);
        border: 1px solid #555;
        margin-top: -2px; position: relative; z-index: 2;
        transition: height 0.1s, transform 0.1s;
    }
    .cable-disc {
        width: 46px; height: 12px;
        background: linear-gradient(to bottom, #ccc, #888);
        border-radius: 50%; border: 1px solid #444;
        margin-top: -2px; position: relative; z-index: 2;
        box-shadow: 0 3px 5px rgba(0,0,0,0.4);
    }
    .cable-grip-body {
        width: 16px; height: 70px;
        background: repeating-linear-gradient(45deg, #666, #666 2px, #888 2px, #888 4px);
        border: 1px solid #333; border-radius: 0 0 4px 4px;
        margin-top: -6px; position: relative; z-index: 1;
        box-shadow: 3px 3px 8px rgba(0,0,0,0.6);
    }
    .cable-plunger-wrapper.pressed .cable-button-head { transform: translateY(12px); }
    .cable-plunger-wrapper.pressed .cable-stem { height: 8px; transform: translateY(12px); }

    .camera-body { width: 100%; height: 310px; position: relative; border-radius: 0 0 8px 8px; perspective: 1000px; }

    .back-lock {
        position: absolute; top: 40px; right: -12px; width: 12px; height: 40px;
        background: linear-gradient(to bottom, #444, #222);
        border: 1px solid #222; border-left: none; border-radius: 0 4px 4px 0;
        border-top: 1px solid #555; border-bottom: 1px solid #555; border-right: 1px solid #555;
        cursor: pointer; z-index: 20; box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
    }
    .back-lock::after { content: ''; width: 4px; height: 20px; background: #111; border-radius: 2px; }
    .back-lock:active { transform: translateX(2px); }

    .back-door-wrapper {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        transform-origin: left center; transform-style: preserve-3d;
        transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1); z-index: 5;
    }
    .back-door-wrapper.open { transform: rotateY(-100deg); }

    .back-door-face {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        background-color: var(--leather-color);
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='leather'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch' result='noise'/%3E%3CfeSpecularLighting in='noise' specularConstant='1.5' specularExponent='30' surfaceScale='4.0' lighting-color='%23eee'%3E%3CfeDistantLight azimuth='45' elevation='50'/%3E%3C/feSpecularLighting%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23leather)' opacity='0.5'/%3E%3C/svg%3E");
        background-size: 140px 140px;
        border-radius: 0 0 8px 8px; 
        border-left: 1px solid #333; border-right: 1px solid #333; border-bottom: 1px solid #333;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 0 50px rgba(0,0,0,0.9);
        backface-visibility: hidden;
    }
    .back-door-interior {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0;
        background: #1a1a1a; border-radius: 0 0 8px 8px; transform: rotateY(180deg);
        backface-visibility: hidden; box-shadow: inset 0 0 20px #000;
        display: flex; justify-content: center; align-items: center; border: 1px solid #333; 
    }
    .pressure-plate { width: 90%; height: 80%; background: repeating-linear-gradient(90deg, #222, #222 20px, #111 20px, #111 22px); border: 2px solid #000; box-shadow: inset 0 0 10px #000; }

    .camera-front-face {
        width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 6;
        background-color: var(--leather-color);
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='leather'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch' result='noise'/%3E%3CfeSpecularLighting in='noise' specularConstant='1.5' specularExponent='30' surfaceScale='4.0' lighting-color='%23eee'%3E%3CfeDistantLight azimuth='45' elevation='50'/%3E%3C/feSpecularLighting%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23leather)' opacity='0.5'/%3E%3C/svg%3E");
        background-size: 140px 140px;
        border-radius: 0 0 8px 8px;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 0 50px rgba(0,0,0,0.9);
        display: none;
        justify-content: center; align-items: center;
    }

    .realistic-lens {
        width: 220px; height: 220px; border-radius: 50%;
        background: linear-gradient(135deg, #333 0%, #111 100%);
        border: 4px solid #222;
        box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 2px 5px rgba(255,255,255,0.1);
        display: flex; justify-content: center; align-items: center;
        position: relative;
    }
    .lens-barrel {
        width: 200px; height: 200px; border-radius: 50%;
        border: 8px solid #111; background: #000;
        display: flex; justify-content: center; align-items: center;
        position: relative;
    }
    
    .lens-glass-element {
        width: 160px; height: 160px; border-radius: 50%;
        background: radial-gradient(circle at 50% 50%, #1a0b2e 0%, #000 80%);
        position: relative; overflow: hidden;
        box-shadow: inset 0 0 40px #000;
    }
    .lens-glass-element::before {
        content: ''; position: absolute; top: -30%; left: -30%; width: 160%; height: 160%;
        background: radial-gradient(circle at 35% 35%, rgba(138, 43, 226, 0.25) 0%, transparent 50%);
        filter: blur(8px); pointer-events: none;
    }
    .lens-glass-element::after {
        content: ''; position: absolute; bottom: 10%; right: 10%; width: 80px; height: 80px;
        background: radial-gradient(circle, rgba(0, 255, 150, 0.15) 0%, transparent 60%);
        filter: blur(10px); pointer-events: none;
    }
    .lens-reflection {
        position: absolute; top: 25%; left: 25%; width: 30px; height: 15px;
        background: rgba(255,255,255,0.3); border-radius: 50%;
        transform: rotate(-45deg); filter: blur(4px); pointer-events: none; z-index: 2;
    }

    .shutter-flash-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: #fff; border-radius: 50%; opacity: 0; pointer-events: none;
        z-index: 5;
    }
    .shutter-flash-overlay.flash { animation: lensFlash 0.15s ease-out; }
    @keyframes lensFlash { 0% { opacity: 0.8; } 100% { opacity: 0; } }

    .camera-interior {
        width: 100%; height: 100%; background: #0a0a0a; border-radius: 0 0 8px 8px;
        box-shadow: inset 0 0 40px #000; position: absolute; top: 0; left: 0; z-index: 1;
        display: flex; flex-direction: column; overflow: hidden;
        border-left: 1px solid #333; border-right: 1px solid #333; border-bottom: 1px solid #333;
    }
    .album-container { flex: 1; padding: 20px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; align-content: flex-start; }
    .album-container::-webkit-scrollbar { width: 8px; }
    .album-container::-webkit-scrollbar-track { background: #111; }
    .album-container::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

    .album-photo { position: relative; border: 2px solid #333; cursor: pointer; transition: transform 0.2s, border-color 0.2s; aspect-ratio: 16 / 9; background: #000; }
    .album-photo img { width: 100%; height: 100%; object-fit: contain; display: block; }
    .album-photo.selected { border-color: #c00; transform: scale(0.95); }
    .album-photo.selected::after { content: '✔'; position: absolute; top: 2px; right: 2px; background: #c00; color: white; font-size: 12px; padding: 2px 4px; }
    .album-seq { position: absolute; top: 2px; left: 2px; font-family: 'Courier New'; font-size: 10px; color: #ff9900; background: rgba(0,0,0,0.7); padding: 1px 3px; }

    .album-controls { height: 50px; background: #181818; border-top: 1px solid #333; display: flex; justify-content: flex-end; align-items: center; padding: 0 20px; gap: 15px; }
    .album-btn { background: transparent; border: 1px solid #666; color: #888; font-family: 'Courier New', monospace; padding: 5px 10px; cursor: pointer; font-size: 12px; }
    .album-btn.action { border-color: #c00; color: #c00; }
    .album-btn.action:hover { background: #c00; color: #fff; }

    .copyright-mark { position: absolute; bottom: 14px; right: 22px; font-family: 'Arial', sans-serif; font-weight: bold; font-size: 12px; letter-spacing: 0.5px; color: rgba(255, 255, 255, 0.25); text-shadow: -1px -1px 1px rgba(0,0,0,0.9), 1px 1px 0 rgba(255,255,255,0.05); pointer-events: none; z-index: 5; text-transform: uppercase; }
    .film-door { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 120px; border: 4px solid #000; background: #1a1a1a; box-shadow: 0 1px 0 rgba(255,255,255,0.1), inset 0 0 10px #000; border-radius: 2px; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 2; }
    .memo-holder-frame { width: 170px; height: 90px; border: 2px solid #333; position: relative; background: #222; display: flex; justify-content: center; align-items: center; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.8); }
    .film-card { width: 150px; height: 70px; background: #f4e9c5; box-shadow: 1px 1px 4px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; transform: rotate(-1deg); transition: filter 0.3s; }
    .film-card::before, .film-card::after { content: ''; position: absolute; width: 100%; height: 6px; background: #333; transition: background 0.3s ease; }
    .film-card::before { top: 0; } .film-card::after { bottom: 0; }
    /* Dynamic Styles for Film Card are set in JS now */
    .film-card h3 { margin: 4px 0 0; font-size: 24px; font-weight: 900; color: #000; line-height: 1; font-family: Impact, sans-serif; }
    .film-card p { margin: 2px 0; font-size: 10px; color: #333; font-weight: bold; text-transform: uppercase; }

    #fs-viewfinder { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: none; cursor: crosshair; touch-action: none; }
    #fs-canvas { width: 100%; height: 100%; object-fit: contain; }
    .fs-ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; box-shadow: inset 0 0 150px rgba(0,0,0,0.7); }
    
    .fs-guide-frame { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; height: 85%; border: 1px solid rgba(255,255,255,0.3); transition: opacity 0.3s; }
    
    .split-image-circle { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        width: 60px; height: 60px; border: 1px solid rgba(255,255,255,0.4); border-radius: 50%; 
        transition: border-color 0.2s, box-shadow 0.2s;
    }
    .split-image-circle.focused { border-color: #0f0; box-shadow: 0 0 15px #0f0, inset 0 0 5px #0f0; }

    .fs-data { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #0f0; font-family: 'Courier New', monospace; font-size: 20px; text-shadow: 0 0 5px #0f0; display: flex; gap: 30px; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px; }
    #vf-close-btn { position: absolute; top: 20px; left: 20px; pointer-events: auto; color: #fff; font-size: 40px; cursor: pointer; opacity: 0.6; font-family: Arial, sans-serif; line-height: 0.5; text-shadow: 0 0 4px #000; z-index: 10001; }
    #vf-close-btn:hover { opacity: 1; }

    .shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1500; animation: shutterAction 0.15s ease-in-out forwards; }
    .flash-effect { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; opacity: 0.8; animation: flashFade 0.2s ease-out forwards; }
    .vf-shutter-blind { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 20; animation: shutterAction 0.15s ease-in-out forwards; pointer-events: none; }
    .vf-flash-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 21; opacity: 0.8; animation: flashFade 0.2s ease-out forwards; pointer-events: none; }
    @keyframes shutterAction { 0% { opacity: 0; } 10% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
    @keyframes flashFade { from { opacity: 0.8; } to { opacity: 0; } }

    #review-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15,15,15,0.98); z-index: 2000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    #review-img { max-width: 90%; max-height: 70%; border: 10px solid #fff; box-shadow: 0 10px 50px rgba(0,0,0,1); }
    .review-controls { margin-top: 30px; display: flex; gap: 40px; }
    .btn-retro { background: transparent; border: 2px solid #fff; color: #fff; padding: 12px 30px; font-family: 'Courier New', monospace; font-weight: bold; font-size: 18px; cursor: pointer; }
    .btn-retro:active { background: #fff; color: #000; }

    #style-selector-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2500; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .style-options { display: flex; gap: 20px; margin-top: 20px; }
    .style-btn { width: 120px; height: 90px; background: #333; border: 2px solid #666; color: #fff; display: flex; justify-content: center; align-items: center; cursor: pointer; flex-direction: column; font-family: 'Courier New'; font-size: 12px; transition: 0.2s; }
    .style-btn:hover { border-color: #c00; color: #c00; }
    .style-preview { width: 60px; height: 40px; background: #111; margin-bottom: 8px; }
    .sp-std { border: none; }
    .sp-white { border: 2px solid white; border-bottom: 4px solid white; background: #333; } 
    .sp-film { border-top: 6px solid black; border-bottom: 6px solid black; background: #333; position: relative; }
    .sp-film::before, .sp-film::after { content: '...'; position: absolute; color: white; font-size: 8px; letter-spacing: 4px; left: 2px; }
    .sp-film::before { top: -8px; } .sp-film::after { bottom: -4px; }

    #developing-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .photo-paper-container { transform: scale(0.9); display: flex; justify-content: center; align-items: center; margin-bottom: 30px; }
    #dev-image-wrap { box-shadow: 0 0 50px #000; opacity: 0; max-height: 80vh; max-width: 80vw; transition: all 0.3s; }
    .dev-status-text { color: #888; font-family: monospace; font-size: 16px; letter-spacing: 2px; animation: pulse 1s infinite; margin-top: 20px;}
    
    #export-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .export-opt-group { margin-top: 20px; display: flex; gap: 20px; }

    #zoom-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5000; display: none; justify-content: center; align-items: center; cursor: zoom-out; }
    #zoom-img { max-width: 95%; max-height: 95%; box-shadow: 0 0 20px #000; object-fit: contain; transition: transform 0.3s ease; }

    @keyframes pulse { 0%,100% {opacity:0.5} 50% {opacity:1}}
    @keyframes developProcess { 0% { opacity: 0; filter: brightness(0.1) blur(20px) sepia(1) contrast(0.8); transform: scale(0.95); } 40% { opacity: 0.6; filter: brightness(0.7) blur(5px) sepia(0.6) contrast(0.9); } 100% { opacity: 1; filter: none; transform: scale(1); } }
</style>
</head>
<body>

    <div id="fullscreen-prompt">
        <p>FULLSCREEN REQUIRED</p>
        <button id="enter-fs-btn">POWER ON</button>
    </div>

    <div id="orientation-lock">
        <svg viewBox="0 0 24 24"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg>
        <p>ROTATE DEVICE</p>
    </div>

    <div id="fs-viewfinder">
        <canvas id="fs-canvas"></canvas>
        <div class="fs-ui-layer">
            <div id="vf-close-btn" title="Exit Viewfinder">×</div>
            <div class="fs-guide-frame" id="fsGuideFrame"></div>
            <div class="split-image-circle" id="splitCircle"></div>
            <div class="fs-data">
                <span id="fs-mode-text">B&W</span><span>1/250</span><span>f/2.8</span><span id="fs-counter">36</span>
            </div>
        </div>
    </div>

    <div id="camera-container">
        <div class="top-plate">
            <div id="back-controls-group">
                <div class="viewfinder-wrap" id="vfTrigger" title="Live View">
                    <canvas class="vf-glass" id="smallCanvas"></canvas>
                </div>
                <div class="lever-base" id="leverBase"></div>
                <div class="advance-lever" id="advanceLever"><div class="lever-grip"></div></div>
                <div class="shutter-release-btn" id="shutterBtn"></div>
                <div class="right-controls">
                    <div class="counter-window"><span class="counter-digits" id="frameCounter">S</span></div>
                    <div class="mode-switch-container" id="rollModeSwitch">
                        <div class="mode-labels"><span>1</span><span>36</span></div>
                        <div class="switch-track"><div class="switch-knob"></div></div>
                    </div>
                </div>
                
                <!-- Sketch Switch -->
                <div class="sketch-switch-container" id="sketchModeSwitch" title="Toggle Real/Sketch Mode">
                    <div class="sketch-labels"><span id="lbl-real" class="active">REAL</span><span id="lbl-sketch">SKETCH</span></div>
                    <div class="sketch-switch-track"><div class="sketch-switch-knob"></div></div>
                </div>
            </div>

            <div id="front-controls-group" class="front-controls-group" style="display:none;">
                <div class="cable-release-container">
                    <div class="cable-plunger-wrapper" id="cablePlunger">
                        <div class="cable-button-head"></div>
                        <div class="cable-stem"></div>
                        <div class="cable-disc"></div>
                        <div class="cable-grip-body"></div>
                    </div>
                </div>

                <div class="front-viewfinder-frame" id="frontVfTrigger">
                    <canvas class="front-vf-glass" id="frontCanvas"></canvas>
                </div>
                <div class="front-shutter-btn" id="frontShutterBtn"></div>
            </div>

            <div class="serial-number">NO. 854021</div>
            <div class="prism-hump"></div>
            <div class="ready-light" id="readyLight"></div>
            <div id="selfie-toggle" title="Switch to Selfie Mode" style="left: 130px;"></div>
        </div>

        <div class="camera-body">
            <div class="camera-interior">
                <div class="album-container" id="albumGrid"></div>
                <div class="album-controls">
                    <button class="album-btn" id="alb-sel-all">SELECT ALL</button>
                    <button class="album-btn action" id="alb-delete" style="border-color:#c00; color:#c00;">DELETE</button>
                    <button class="album-btn action" id="alb-download">DOWNLOAD</button>
                    <button class="album-btn action" id="alb-share">SHARE</button>
                </div>
            </div>
            
            <div class="camera-front-face" id="frontFace">
                <div class="realistic-lens">
                    <div class="lens-barrel">
                        <div class="lens-glass-element">
                            <div class="lens-reflection"></div>
                            <div class="shutter-flash-overlay" id="shutterFlash"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="back-door-wrapper" id="backDoorWrapper">
                <div class="back-door-face">
                    <div class="copyright-mark">Designed by Chan Kwun Kin</div>
                    <div class="film-door" id="filmDoor">
                        <div class="memo-holder-frame">
                            <div class="film-card">
                                <h3 id="modeTitle">B&W</h3>
                                <p id="modeSub">TRI-X 400</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="back-door-interior">
                    <div class="pressure-plate"></div>
                </div>
            </div>
            <div class="back-lock" id="backLock" title="Open Back"></div>
        </div>
    </div>

    <div id="style-selector-overlay">
        <h2 style="color:white; font-family:'Courier New'; text-align:center;">SELECT PRINT STYLE</h2>
        <div class="style-options">
            <div class="style-btn" data-style="standard">
                <div class="style-preview sp-std"></div>
                STANDARD
            </div>
            <div class="style-btn" data-style="white">
                <div class="style-preview sp-white"></div>
                INSTANT
            </div>
            <div class="style-btn" data-style="film">
                <div class="style-preview sp-film"></div>
                FILM
            </div>
        </div>
    </div>

    <div id="review-overlay">
        <img id="review-img" src="" alt="Review">
        <div class="review-controls">
            <button class="btn-retro" id="btn-discard">DISCARD</button>
            <button class="btn-retro" id="btn-keep">KEEP</button>
        </div>
    </div>

    <div id="developing-overlay">
        <div class="photo-paper-container">
            <img id="dev-image-wrap" src="" alt="Developing">
        </div>
        <div class="dev-status-text" id="devStatus">DEVELOPING...</div>
    </div>
    
    <div id="zoom-overlay">
        <img id="zoom-img" src="" alt="Zoomed Photo">
    </div>

    <div id="export-modal">
        <h2 style="color:#c00; font-family:'Courier New'">EXPORT OPTIONS</h2>
        <p style="color:#fff; font-family:sans-serif">Include Serial Number?</p>
        <div class="export-opt-group">
            <button class="btn-retro" id="exp-no-serial">NO SERIAL</button>
            <button class="btn-retro" id="exp-with-serial" style="border-color:#c00; color:#c00">WITH SERIAL</button>
        </div>
        <button class="btn-retro" id="exp-cancel" style="margin-top:30px; border:none; opacity:0.5">CANCEL</button>
    </div>

    <video id="video-source" autoplay playsinline style="display:none"></video>
    <canvas id="process-canvas" style="display:none"></canvas>
    <canvas id="final-canvas" style="display:none"></canvas>
    <canvas id="grain-canvas" style="display:none"></canvas>
    <!-- Medium Res Canvas for Smooth Sketch Effect -->
    <canvas id="sketch-canvas" style="display:none"></canvas>

    <script>
        const DB_NAME = "RetroCamDB_ProMax";
        const TEMP_STORE = "temp_roll"; 
        const ALBUM_STORE = "user_album";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 3);
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(TEMP_STORE)) { db.createObjectStore(TEMP_STORE, { autoIncrement: true }); }
                    if (!db.objectStoreNames.contains(ALBUM_STORE)) { db.createObjectStore(ALBUM_STORE, { keyPath: "id", autoIncrement: true }); }
                };
                request.onsuccess = (e) => { db = e.target.result; resolve(db); };
                request.onerror = () => reject("DB Error");
            });
        }

        function saveToTemp(dataUrl) { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readwrite"); tx.objectStore(TEMP_STORE).add({ image: dataUrl, date: new Date() }).onsuccess = () => resolve(true); }); }
        function getTempCount() { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readonly"); tx.objectStore(TEMP_STORE).count().onsuccess = (e) => resolve(e.target.result); }); }
        function getTempPhotos() { return new Promise((resolve) => { const tx = db.transaction([TEMP_STORE], "readonly"); tx.objectStore(TEMP_STORE).getAll().onsuccess = (e) => resolve(e.target.result); }); }
        function clearTemp() { return new Promise(resolve => { db.transaction([TEMP_STORE], "readwrite").objectStore(TEMP_STORE).clear().onsuccess = resolve; }); }
        function saveToAlbum(processedImage, serialNumber, styleInfo) { return new Promise(resolve => { const tx = db.transaction([ALBUM_STORE], "readwrite"); tx.objectStore(ALBUM_STORE).add({ image: processedImage, timestamp: Date.now(), serial: serialNumber, style: styleInfo }).onsuccess = resolve; }); }
        function getAlbumPhotos() { return new Promise(resolve => { const tx = db.transaction([ALBUM_STORE], "readonly"); tx.objectStore(ALBUM_STORE).getAll().onsuccess = (e) => resolve(e.target.result); }); }
        function deleteFromAlbum(ids) { return new Promise(resolve => { const tx = db.transaction([ALBUM_STORE], "readwrite"); const store = tx.objectStore(ALBUM_STORE); ids.forEach(id => store.delete(id)); tx.oncomplete = resolve; }); }

        // State Variables
        let isRollMode = localStorage.getItem('rollMode') === 'true';
        let currentFrame = 0;
        let pendingPhoto = null;
        let globalSerialCounter = parseInt(localStorage.getItem('global_serial_counter') || '1');
        let isSelfieMode = false;
        let isSketchMode = false;
        
        // SEPARATE MODE LISTS
        const REAL_MODES = [
            { id: 'BW', name: 'B&W', sub: 'TRI-X 400', color: '#000' },
            { id: 'COLOR', name: 'COLOR', sub: 'GAME-CAM', color: '#c00' },
            { id: 'CCD', name: 'DIGI', sub: 'CCD SENSOR', color: '#0055cc' },
            { id: 'FILM', name: 'FILM', sub: 'JPN-CYAN', color: '#007700' },
            { id: 'HCBW', name: 'HC-BW', sub: 'ACROS 100', color: '#555' }
        ];

        const SKETCH_MODES = [
            { id: 'SKETCH_BW', name: 'PENCIL', sub: '2B GRAPHITE', color: '#333' },
            { id: 'SKETCH_COL', name: 'CRAYON', sub: 'SOFT PASTEL', color: '#d2691e' }
        ];
        
        let savedMode = localStorage.getItem('camModeIdx');
        let currentModeIdx = savedMode ? parseInt(savedMode) : 0;
        
        // Ensure index is valid for the current state
        function getModes() { return isSketchMode ? SKETCH_MODES : REAL_MODES; }
        function validateModeIndex() {
            const modes = getModes();
            if (currentModeIdx < 0 || currentModeIdx >= modes.length) currentModeIdx = 0;
        }
        validateModeIndex();

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const actx = new AudioContext();

        function playShutterSound() {
            if (actx.state === 'suspended') actx.resume();
            const t = actx.currentTime;
            const oscLow = actx.createOscillator(); const gainLow = actx.createGain();
            oscLow.frequency.setValueAtTime(150, t); oscLow.frequency.exponentialRampToValueAtTime(40, t + 0.1);
            gainLow.gain.setValueAtTime(3.5, t); gainLow.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            oscLow.connect(gainLow).connect(actx.destination); oscLow.start(t); oscLow.stop(t + 0.1);
            const bufferSize = actx.sampleRate * 0.1; 
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = actx.createBufferSource(); noise.buffer = buffer;
            const noiseFilter = actx.createBiquadFilter(); noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1200;
            const noiseGain = actx.createGain(); 
            noiseGain.gain.setValueAtTime(3.0, t); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
            noise.connect(noiseFilter).connect(noiseGain).connect(actx.destination); noise.start(t);
            const oscHigh = actx.createOscillator(); const gainHigh = actx.createGain();
            oscHigh.type = 'triangle'; oscHigh.frequency.setValueAtTime(800, t + 0.04); oscHigh.frequency.exponentialRampToValueAtTime(100, t + 0.1);
            gainHigh.gain.setValueAtTime(0.0, t); gainHigh.gain.setValueAtTime(1.5, t + 0.04); gainHigh.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            oscHigh.connect(gainHigh).connect(actx.destination); oscHigh.start(t); oscHigh.stop(t + 0.2);
        }

        function playFocusSound() {
            if (actx.state === 'suspended') actx.resume();
            const t = actx.currentTime;
            const osc = actx.createOscillator(); const gain = actx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
            gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.connect(gain).connect(actx.destination); osc.start(t); osc.stop(t + 0.15);
        }

        function playLeverSound() {
            if (actx.state === 'suspended') actx.resume();
            const t = actx.currentTime;
            for(let i=0; i<5; i++) {
                const osc = actx.createOscillator(); const gain = actx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t + i*0.06); osc.frequency.exponentialRampToValueAtTime(100, t + i*0.06 + 0.03);
                gain.gain.setValueAtTime(1.2, t + i*0.06); gain.gain.exponentialRampToValueAtTime(0.01, t + i*0.06 + 0.03);
                osc.connect(gain); gain.connect(actx.destination); osc.start(t + i*0.06); osc.stop(t + i*0.06 + 0.04);
            }
        }

        // DOM Elements
        const video = document.getElementById('video-source');
        const smallCanvas = document.getElementById('smallCanvas');
        const smallCtx = smallCanvas.getContext('2d', { alpha: false });
        const frontCanvas = document.getElementById('frontCanvas');
        const frontCtx = frontCanvas.getContext('2d', { alpha: false });
        const fsCanvas = document.getElementById('fs-canvas');
        const fsCtx = fsCanvas.getContext('2d', { alpha: false });
        const processCanvas = document.getElementById('process-canvas');
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });
        const finalCanvas = document.getElementById('final-canvas');
        const finalCtx = finalCanvas.getContext('2d');
        const grainCanvas = document.getElementById('grain-canvas');
        const grainCtx = grainCanvas.getContext('2d');
        const sketchCanvas = document.getElementById('sketch-canvas');
        const sketchCtx = sketchCanvas.getContext('2d', { willReadFrequently: true });
        
        const rollModeSwitch = document.getElementById('rollModeSwitch');
        const sketchModeSwitch = document.getElementById('sketchModeSwitch');
        
        const frameCounterUI = document.getElementById('frameCounter');
        const fsCounter = document.getElementById('fs-counter');
        const readyLight = document.getElementById('readyLight');
        const leverBase = document.getElementById('leverBase');
        const advanceLever = document.getElementById('advanceLever');
        const shutterBtn = document.getElementById('shutterBtn');
        
        const vfTrigger = document.getElementById('vfTrigger');
        const frontVfTrigger = document.getElementById('frontVfTrigger');
        const frontShutterBtn = document.getElementById('frontShutterBtn');
        const fsViewfinder = document.getElementById('fs-viewfinder');
        const vfCloseBtn = document.getElementById('vf-close-btn');
        const fsGuideFrame = document.getElementById('fsGuideFrame');
        const splitCircle = document.getElementById('splitCircle');

        const backLock = document.getElementById('backLock');
        const backDoorWrapper = document.getElementById('backDoorWrapper');
        const frontFace = document.getElementById('frontFace');
        const shutterFlash = document.getElementById('shutterFlash');
        const selfieToggle = document.getElementById('selfie-toggle');
        const backControls = document.getElementById('back-controls-group');
        const frontControls = document.getElementById('front-controls-group');
        
        const cablePlunger = document.getElementById('cablePlunger');
        const albumGrid = document.getElementById('albumGrid');
        const styleOverlay = document.getElementById('style-selector-overlay');
        const devOverlay = document.getElementById('developing-overlay');
        const devImageWrap = document.getElementById('dev-image-wrap');
        const devStatus = document.getElementById('devStatus');
        const filmCard = document.querySelector('.film-card');
        const modeTitle = document.getElementById('modeTitle');
        const modeSub = document.getElementById('modeSub');
        const fsPrompt = document.getElementById('fullscreen-prompt');
        const zoomOverlay = document.getElementById('zoom-overlay');
        const zoomImg = document.getElementById('zoom-img');

        // Grain System
        function initGrainSystem() {
            grainCanvas.width = 512; grainCanvas.height = 512;
            const imgData = grainCtx.createImageData(512, 512); const data = imgData.data;
            for(let i=0; i<data.length; i+=4) {
                let u = 0, v = 0; while(u === 0) u = Math.random(); while(v === 0) v = Math.random();
                let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
                let gray = 128 + num * 40; 
                data[i] = gray; data[i+1] = gray; data[i+2] = gray; data[i+3] = 255;
            }
            grainCtx.putImageData(imgData, 0, 0);
        }

        // Mode UI Update
        function updateModeUI() {
            const modes = getModes();
            if(currentModeIdx >= modes.length) currentModeIdx = 0;
            const m = modes[currentModeIdx];
            
            modeTitle.textContent = m.name; 
            modeSub.textContent = m.sub; 
            document.getElementById('fs-mode-text').textContent = m.name;
            
            const h3 = filmCard.querySelector('h3');
            // Remove old data attribute styling logic
            h3.style.color = m.color;
            
            // Force film card styling
            filmCard.className = 'film-card';
            filmCard.querySelector('h3').style.color = m.color;
            
            // Custom film card strip color
            const styleEl = document.createElement('style');
            styleEl.innerHTML = `.film-card::before, .film-card::after { background: ${m.color} !important; }`;
            const oldStyle = document.getElementById('film-card-style');
            if(oldStyle) oldStyle.remove();
            styleEl.id = 'film-card-style';
            document.head.appendChild(styleEl);
        }
        updateModeUI();

        // System Init
        async function initSystem() {
            await initDB();
            initGrainSystem(); 
            
            if (isRollMode) {
                rollModeSwitch.classList.add('mode-36');
                currentFrame = await getTempCount();
            } else {
                rollModeSwitch.classList.remove('mode-36');
                currentFrame = 0;
            }
            checkLeverState();
            updateCounterDisplay();
        }

        function updateCounterDisplay() {
            if (!isRollMode) {
                frameCounterUI.textContent = "S"; fsCounter.textContent = "1";
            } else {
                if (currentFrame === 0) frameCounterUI.textContent = "S";
                else if (currentFrame >= 36) frameCounterUI.textContent = "E";
                else frameCounterUI.textContent = currentFrame;
                fsCounter.textContent = (36 - currentFrame) + " LEFT";
            }
        }

        function checkLeverState() {
            if ((isRollMode && currentFrame >= 36) || (!isRollMode && pendingPhoto)) {
                readyLight.classList.add('active'); leverBase.classList.add('glow');
            } else {
                readyLight.classList.remove('active'); leverBase.classList.remove('glow');
            }
        }

        document.getElementById('enter-fs-btn').addEventListener('click', () => { startFullscreenAndCamera(); });

        function startFullscreenAndCamera() {
            const el = document.documentElement;
            const rfs = el.requestFullscreen || el.webkitRequestFullScreen;
            if (rfs) {
                rfs.call(el).then(() => { initSystem().then(initCamera); }).catch(() => { initSystem().then(initCamera); });
            }
        }

        async function initCamera() {
            try {
                if(video.srcObject) { video.srcObject.getTracks().forEach(track => track.stop()); }
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: isSelfieMode ? 'user' : 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, 
                    audio: false 
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => { video.play(); renderLoop(); };
            } catch (err) { console.error("Camera Error", err); }
        }

        function enforceFullscreen() {
            if (!document.fullscreenElement) {
                fsPrompt.style.display = 'flex';
                document.getElementById('camera-container').style.display = 'none';
                fsViewfinder.style.display = 'none';
            }
        }

        document.addEventListener('fullscreenchange', enforceFullscreen);
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                enforceFullscreen();
                if(video.srcObject && video.paused) video.play();
            }
        });

        // -------------------------
        // REFINED SKETCH EFFECT (The Golden Mean)
        // -------------------------
        
        function applySketchEffect(sourceVideo, destCtx, width, height, useColor) {
            // Increased resolution for smoother lines (720 width base)
            const scanW = 800; 
            const scanH = Math.floor(scanW * (height/width));
            
            if(sketchCanvas.width !== scanW) {
                sketchCanvas.width = scanW;
                sketchCanvas.height = scanH;
            }
            
            sketchCtx.drawImage(sourceVideo, 0, 0, scanW, scanH);
            const frame = sketchCtx.getImageData(0, 0, scanW, scanH);
            const data = frame.data;
            const output = sketchCtx.createImageData(scanW, scanH);
            const outData = output.data;
            
            // Lower threshold -> More lines
            const threshold = 15; 

            for(let y = 0; y < scanH; y++) {
                for(let x = 0; x < scanW; x++) {
                    const i = (y * scanW + x) * 4;
                    
                    // Current brightness
                    const val = (data[i] + data[i+1] + data[i+2]) / 3;
                    
                    // Neighbor brightness (Right/Bottom)
                    let rightVal = val;
                    let bottomVal = val;
                    
                    if(x < scanW - 1) {
                        const ir = i + 4;
                        rightVal = (data[ir] + data[ir+1] + data[ir+2]) / 3;
                    }
                    if(y < scanH - 1) {
                        const ib = i + scanW * 4;
                        bottomVal = (data[ib] + data[ib+1] + data[ib+2]) / 3;
                    }
                    
                    const diff = Math.abs(val - rightVal) + Math.abs(val - bottomVal);
                    
                    // Base Paper Color (Clean, very slight noise)
                    // Almost white: 250-255 range
                    const basePaper = 250 + (Math.random() * 5); 

                    if (diff > threshold) {
                        // Edge - Dark charcoal gray (not pure black for softness)
                        // Intensity based on diff
                        const intensity = Math.min(diff * 2, 150);
                        const edgeColor = 60 - (intensity / 5); // 30 to 60 range
                        
                        outData[i] = edgeColor;
                        outData[i+1] = edgeColor;
                        outData[i+2] = edgeColor;
                    } else {
                        // Non-Edge area
                        if(useColor) {
                            // Color Sketch: Blend original color with paper white
                            // Result is pastel-like
                            outData[i] = Math.min(255, data[i] + 100); 
                            outData[i+1] = Math.min(255, data[i+1] + 100);
                            outData[i+2] = Math.min(255, data[i+2] + 100);
                        } else {
                            // B&W Sketch: Just paper
                            // Extremely subtle noise (0.2% chance)
                            if(Math.random() > 0.998) {
                                outData[i] = 200; outData[i+1] = 200; outData[i+2] = 200;
                            } else {
                                outData[i] = basePaper;
                                outData[i+1] = basePaper;
                                outData[i+2] = basePaper;
                            }
                        }
                    }
                    outData[i+3] = 255;
                }
            }
            
            sketchCtx.putImageData(output, 0, 0);
            
            // Draw without smoothing for crispness, but high res makes it look fine
            destCtx.imageSmoothingEnabled = true; 
            destCtx.drawImage(sketchCanvas, 0, 0, width, height);
        }

        // -------------------------
        
        selfieToggle.addEventListener('click', () => {
            if(isSketchMode) return; 
            isSelfieMode = !isSelfieMode;
            if (isSelfieMode) {
                backDoorWrapper.style.display = 'none'; frontFace.style.display = 'flex';
                backControls.style.display = 'none'; frontControls.style.display = 'block';
            } else {
                backDoorWrapper.style.display = 'block'; frontFace.style.display = 'none';
                backControls.style.display = 'block'; frontControls.style.display = 'none';
            }
            initCamera(); 
        });

        // Sketch Mode Toggle Logic
        sketchModeSwitch.addEventListener('click', () => {
            isSketchMode = !isSketchMode;
            sketchModeSwitch.classList.toggle('mode-sketch', isSketchMode);
            document.getElementById('lbl-real').classList.toggle('active', !isSketchMode);
            document.getElementById('lbl-sketch').classList.toggle('active', isSketchMode);
            
            // Reset to first mode of the new set
            currentModeIdx = 0;
            
            if (isSketchMode) {
                selfieToggle.style.opacity = '0.3'; selfieToggle.style.pointerEvents = 'none';
            } else {
                selfieToggle.style.opacity = '1'; selfieToggle.style.pointerEvents = 'auto';
            }
            
            filmCard.style.filter = 'blur(5px)';
            setTimeout(() => { updateModeUI(); filmCard.style.filter = 'none'; }, 200);
        });

        function renderLoop() {
            requestAnimationFrame(renderLoop);

            const modes = getModes();
            validateModeIndex();
            const mode = modes[currentModeIdx];
            
            let w = 960; let h = 540;
            
            // Force low-res pixelation for COLOR/BW modes in Real Mode
            if (!isSketchMode && (mode.id === 'COLOR' || mode.id === 'BW')) { w = 320; h = 180; } 
            
            if (processCanvas.width !== w) { processCanvas.width = w; processCanvas.height = h; }
            
            processCtx.filter = "none";
            if (!video.srcObject || !video.srcObject.active || video.paused) return;
            
            if (isSketchMode) {
                const useColor = (mode.id === 'SKETCH_COL');
                applySketchEffect(video, processCtx, w, h, useColor);
            } else {
                // Standard Video Feed
                processCtx.drawImage(video, 0, 0, w, h);
            
                let imgData = processCtx.getImageData(0, 0, w, h);
                let data = imgData.data;
                
                if (mode.id === 'FILM') {
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];
                        r = r < 40 ? 40 + (r*0.5) : r; b = b < 50 ? 50 + (b*0.5) : b;
                        r = r * 0.96; g = g * 1.01; b = b * 1.04; 
                        data[i] = r; data[i+1] = g; data[i+2] = b;
                    }
                } 
                else if (mode.id === 'BW') {
                    for (let i = 0; i < data.length; i += 4) {
                        let lum = data[i] * 0.3 + data[i+1] * 0.59 + data[i+2] * 0.11;
                        if (lum < 128) lum = Math.pow(lum/128, 1.15) * 128; else lum = 128 + Math.pow((lum-128)/128, 0.9) * 128;
                        data[i] = data[i+1] = data[i+2] = lum;
                    }
                }
                else if (mode.id === 'COLOR') {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.round(data[i] / 50) * 50; data[i+1] = Math.round(data[i+1] / 50) * 50; data[i+2] = Math.round(data[i+2] / 50) * 50;
                    }
                }
                else if (mode.id === 'HCBW') {
                    for (let i = 0; i < data.length; i += 4) {
                        let lum = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
                        lum = (lum - 40) * 1.25; if(lum < 0) lum = 0; if(lum > 255) lum = 255;
                        data[i] = data[i+1] = data[i+2] = lum;
                    }
                }
                
                processCtx.putImageData(imgData, 0, 0);

                // Apply Grain
                if (mode.id !== 'CCD' && mode.id !== 'COLOR') {
                    processCtx.save(); processCtx.globalCompositeOperation = "overlay"; 
                    let grainOpacity = 0.25; if(mode.id === 'BW') grainOpacity = 0.35; if(mode.id === 'FILM') grainOpacity = 0.22; 
                    processCtx.globalAlpha = grainOpacity; processCtx.imageSmoothingEnabled = true; 
                    const scale = 1.6; const offsetX = Math.random() * 128; const offsetY = Math.random() * 128;
                    processCtx.scale(scale, scale); processCtx.translate(offsetX, offsetY);
                    processCtx.fillStyle = processCtx.createPattern(grainCanvas, 'repeat');
                    processCtx.fillRect(-offsetX, -offsetY, (w/scale) + offsetX, (h/scale) + offsetY);
                    processCtx.restore();
                }
            }

            // Render to Viewfinders
            const isPixelated = (!isSketchMode && (mode.id === 'COLOR' || mode.id === 'BW'));
            
            if (!isSelfieMode) {
                if (smallCanvas.width !== w) { smallCanvas.width = w; smallCanvas.height = h; }
                smallCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto';
                smallCtx.drawImage(processCanvas, 0, 0);
            } else {
                if (frontCanvas.width !== w) { frontCanvas.width = w; frontCanvas.height = h; }
                frontCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto';
                frontCtx.drawImage(processCanvas, 0, 0);
            }

            if (fsViewfinder.style.display === 'block') {
                if (fsCanvas.width !== w) { fsCanvas.width = w; fsCanvas.height = h; }
                fsCanvas.style.imageRendering = isPixelated ? 'pixelated' : 'auto';
                fsCanvas.style.transform = (isSelfieMode && !isSketchMode) ? 'scaleX(-1)' : 'none';
                fsCtx.drawImage(processCanvas, 0, 0);
            }
        }

        // Viewfinder Interaction
        vfTrigger.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            fsViewfinder.style.display = 'block'; 
            if(isSketchMode) {
                splitCircle.style.display = 'none';
                fsGuideFrame.style.display = 'none';
            } else {
                splitCircle.style.display = 'block';
                fsGuideFrame.style.display = 'block';
            }
        });
        
        frontVfTrigger.addEventListener('click', (e) => { e.stopPropagation(); if (video.readyState >= 2) fsViewfinder.style.display = 'block'; });

        vfCloseBtn.addEventListener('click', (e) => { 
            e.stopPropagation(); 
            fsViewfinder.style.display = 'none'; 
        });

        fsViewfinder.addEventListener('click', (e) => {
            if(e.target.id !== 'vf-close-btn') {
               playFocusSound();
               if(!isSketchMode) {
                   splitCircle.classList.add('focused');
                   fsCanvas.style.filter = 'blur(0px) contrast(1.1)';
                   setTimeout(() => { 
                       splitCircle.classList.remove('focused'); 
                       fsCanvas.style.filter = 'none';
                       handleShutter(e);
                   }, 400);
               } else {
                   // Instant snap in Sketch Mode
                   handleShutter(e);
               }
            }
        });

        shutterBtn.addEventListener('click', handleShutter);
        frontShutterBtn.addEventListener('click', handleShutter);
        cablePlunger.addEventListener('click', (e) => { e.stopPropagation(); cablePlunger.classList.add('pressed'); setTimeout(() => cablePlunger.classList.remove('pressed'), 200); handleShutter(e); });
        
        function handleShutter(e) {
            if(e) e.stopPropagation();
            if (e && e.target.id === 'vf-close-btn') return;
            if (!isSelfieMode && backDoorWrapper.classList.contains('open')) return;
            if (isRollMode && currentFrame >= 36) return;
            if (!isRollMode && pendingPhoto) return;

            const btn = isSelfieMode ? frontShutterBtn : shutterBtn;
            btn.classList.add('pressed');
            playShutterSound();
            
            if (isSelfieMode) {
                shutterFlash.classList.add('flash');
                setTimeout(() => shutterFlash.classList.remove('flash'), 150);
            } else {
                const container = (fsViewfinder.style.display === 'block') ? fsViewfinder : vfTrigger;
                const blind = document.createElement('div'); blind.className = container === fsViewfinder ? 'shutter-blind' : 'vf-shutter-blind';
                container.appendChild(blind); setTimeout(() => blind.remove(), 150);
            }
            
            setTimeout(() => { performCapture(); btn.classList.remove('pressed'); }, 150);
        }

        // Generate Light Leak (Real Mode Only)
        function generateLightLeak(ctx, w, h) {
            ctx.save(); ctx.globalCompositeOperation = 'screen'; 
            const leakCount = Math.random() > 0.7 ? 2 : 1; 
            for(let i=0; i<leakCount; i++) {
                const type = Math.random(); const opacity = 0.4 + Math.random() * 0.4; 
                const hue = Math.random() > 0.8 ? 40 + Math.random()*10 : 10 + Math.random()*30; 
                const sat = 80 + Math.random()*20; const light = 50 + Math.random()*20;
                const colorInner = `hsla(${hue}, ${sat}%, ${light}%, ${opacity})`;
                const colorOuter = `hsla(${hue-10}, ${sat}%, ${light-20}%, 0)`;

                if (type < 0.4) {
                    const isLeft = Math.random() > 0.5; const width = w * (0.15 + Math.random() * 0.3);
                    const grad = ctx.createLinearGradient(isLeft ? 0 : w, 0, isLeft ? width : w - width, 0);
                    grad.addColorStop(0, colorInner); grad.addColorStop(1, colorOuter);
                    ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                } else if (type < 0.7) {
                    const cx = Math.random() > 0.5 ? 0 : w; const cy = Math.random() > 0.5 ? 0 : h;
                    const r = Math.max(w, h) * (0.4 + Math.random() * 0.4);
                    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                    grad.addColorStop(0, `hsla(${hue}, 20%, 90%, ${opacity})`);
                    grad.addColorStop(0.4, colorInner); grad.addColorStop(1, `hsla(${hue}, ${sat}%, 20%, 0)`);
                    ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                } else {
                    const angle = (Math.random() - 0.5) * Math.PI / 2; 
                    ctx.translate(w/2, h/2); ctx.rotate(angle);
                    const grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
                    grad.addColorStop(0, 'transparent'); grad.addColorStop(Math.random() * 0.4 + 0.2, colorInner); grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad; ctx.fillRect(-w, -h, w*2, h*2); ctx.setTransform(1,0,0,1,0,0);
                }
            }
            ctx.restore();
        }

        async function performCapture() {
            const modes = getModes();
            const mode = modes[currentModeIdx];
            const targetW = 1920, targetH = 1080;
            finalCanvas.width = targetW; finalCanvas.height = targetH;
            finalCtx.filter = 'none'; finalCtx.globalCompositeOperation = 'source-over';

            if (isSelfieMode && !isSketchMode) { finalCtx.translate(targetW, 0); finalCtx.scale(-1, 1); }
            finalCtx.imageSmoothingEnabled = (mode.id === 'FILM' || mode.id === 'HCBW' || mode.id === 'CCD' || mode.id.includes('SKETCH'));
            finalCtx.drawImage(processCanvas, 0, 0, targetW, targetH); 

            if (mode.id === 'FILM') generateLightLeak(finalCtx, targetW, targetH);
            finalCtx.setTransform(1, 0, 0, 1, 0, 0);
            const highRes = finalCanvas.toDataURL('image/jpeg', 0.92);

            if (isRollMode) {
                await saveToTemp(highRes); currentFrame++; updateCounterDisplay(); checkLeverState();
            } else {
                pendingPhoto = highRes;
                document.getElementById('review-img').src = highRes;
                document.getElementById('review-overlay').style.display = 'flex';
                fsViewfinder.style.display = 'none';
            }
        }

        document.getElementById('btn-discard').addEventListener('click', () => { pendingPhoto = null; document.getElementById('review-overlay').style.display = 'none'; });
        document.getElementById('btn-keep').addEventListener('click', () => { document.getElementById('review-overlay').style.display = 'none'; checkLeverState(); });
        document.getElementById('filmDoor').addEventListener('click', () => { 
            if (backDoorWrapper.classList.contains('open')) return; 
            const modes = getModes();
            currentModeIdx = (currentModeIdx + 1) % modes.length; 
            localStorage.setItem('camModeIdx', currentModeIdx); 
            filmCard.style.filter = 'blur(5px)'; 
            setTimeout(() => { updateModeUI(); filmCard.style.filter = 'none'; }, 200); 
        });
        
        rollModeSwitch.addEventListener('click', async () => {
            if(pendingPhoto || (isRollMode && currentFrame > 0 && currentFrame < 36)) {
                if(!confirm("Switching modes will clear current roll. Continue?")) return;
                await clearTemp(); pendingPhoto = null;
            }
            isRollMode = !isRollMode; localStorage.setItem('rollMode', isRollMode);
            rollModeSwitch.classList.toggle('mode-36', isRollMode);
            currentFrame = 0; updateCounterDisplay(); checkLeverState();
        });

        let leverPulled = false;
        advanceLever.addEventListener('click', async () => {
            if (!readyLight.classList.contains('active') || leverPulled) return;
            playLeverSound(); leverPulled = true; advanceLever.style.transform = 'rotate(130deg)';
            setTimeout(() => { advanceLever.style.transform = 'rotate(10deg)'; styleOverlay.style.display = 'flex'; leverPulled = false; }, 400);
        });

        document.querySelectorAll('.style-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const style = e.currentTarget.dataset.style; styleOverlay.style.display = 'none'; readyLight.classList.remove('active'); leverBase.classList.remove('glow');
                let photosToProcess = [];
                if (isRollMode) photosToProcess = await getTempPhotos(); else if (pendingPhoto) photosToProcess = [{ image: pendingPhoto, date: new Date() }];
                if(photosToProcess.length > 0) await startDevelopingAnimation(photosToProcess, style);
            });
        });

        function applyFrameAndDate(imgUrl, dateObj, style) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    let w = 1920, h = 1080; let padTop = 0, padSide = 0, padBottom = 0;
                    if (style === 'white') { padTop = 50; padSide = 50; padBottom = 150; w = 1200; h = Math.floor(w * (9/16)) + padTop + padBottom; } else if (style === 'film') { padTop = 80; padSide = 0; padBottom = 80; }
                    finalCanvas.width = w; finalCanvas.height = h; const ctx = finalCanvas.getContext('2d'); ctx.filter = 'none';
                    if (style === 'white') { ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h); ctx.drawImage(img, padSide, padTop, w - padSide*2, h - padTop - padBottom); } 
                    else if (style === 'film') {
                        ctx.drawImage(img, 0, padTop, w, h - padTop*2); ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, padTop); ctx.fillRect(0, h - padBottom, w, padBottom); ctx.fillStyle = '#fff'; const holeW = 30, gap = 20;
                        for(let x = 30; x < w; x += (holeW + gap)) { ctx.fillRect(x, 20, holeW, 40); ctx.fillRect(x, h - 60, holeW, 40); }
                    } else { ctx.drawImage(img, 0, 0, w, h); }
                    
                    // DATE STAMP STYLING
                    const d = new Date(dateObj); const dateStr = `'${d.getFullYear().toString().slice(-2)} ${(d.getMonth()+1).toString().padStart(2,'0')} ${d.getDate().toString().padStart(2,'0')}`;
                    let dateX = (style === 'white') ? w - padSide - 30 : ((style === 'film') ? w - 50 : w - 60); let dateY = (style === 'white' || style === 'film') ? h - padBottom - 30 : h - 50;
                    
                    if (isSketchMode) {
                        // Sketch: Handwritten, Dark Grey, No Glow, Slightly Tilted
                        ctx.save();
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = 'rgba(50, 50, 50, 0.85)';
                        // Trying standard cursive fonts available on most systems
                        ctx.font = `normal 45px "Segoe Print", "Comic Sans MS", "Chalkboard SE", cursive`;
                        ctx.textAlign = 'right'; 
                        ctx.textBaseline = 'bottom';
                        ctx.translate(dateX, dateY);
                        ctx.rotate(-0.05); // Slight tilt
                        ctx.fillText(dateStr, 0, 0);
                        ctx.restore();
                    } else {
                        // Real: Orange Digital, Glow
                        ctx.shadowColor = '#ff5500'; ctx.shadowBlur = 15; ctx.fillStyle = 'rgba(255, 170, 50, 0.9)'; const fontSize = style === 'white' ? 40 : 50; ctx.font = `bold ${fontSize}px "Courier New", monospace`; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                        ctx.fillText(dateStr, dateX, dateY); 
                    }
                    
                    resolve(finalCanvas.toDataURL('image/jpeg', 0.9));
                }; img.src = imgUrl;
            });
        }

        function overlaySerial(imgUrl, serialNo, style) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    finalCanvas.width = img.width; finalCanvas.height = img.height; const ctx = finalCanvas.getContext('2d'); ctx.drawImage(img, 0, 0);
                    let x = 30, y = 30, color = '#fff';
                    if (style === 'white') { x = 50; y = img.height - 80; color = '#333'; } else if (style === 'film') { x = 40; y = 100; color = 'rgba(255,255,255,0.8)'; } else { color = 'rgba(255,255,255,0.8)'; }
                    ctx.shadowColor = style === 'white' ? 'transparent' : '#000'; ctx.shadowBlur = 2; ctx.fillStyle = color; ctx.font = `bold 36px "Courier New", monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(`No.${serialNo}`, x, y); resolve(finalCanvas.toDataURL('image/jpeg', 0.9));
                }; img.src = imgUrl;
            });
        }

        async function startDevelopingAnimation(photos, style) {
            devOverlay.style.display = 'flex'; devStatus.textContent = "PREPARING...";
            const processed = [];
            for (let p of photos) { const thisSerial = globalSerialCounter++; localStorage.setItem('global_serial_counter', globalSerialCounter); const finalImg = await applyFrameAndDate(p.image, p.date, style); processed.push({ img: finalImg, serial: thisSerial, style: style }); }
            for (let i = 0; i < processed.length; i++) {
                devStatus.textContent = `DEVELOPING ${i+1}/${processed.length}`; devImageWrap.src = processed[i].img; devImageWrap.style.border = style === 'white' ? 'none' : '8px solid white';
                devImageWrap.style.animation = 'none'; devImageWrap.offsetHeight; devImageWrap.style.animation = 'developProcess 3s forwards'; await new Promise(r => setTimeout(r, 3200)); await saveToAlbum(processed[i].img, processed[i].serial, processed[i].style);
            }
            devStatus.textContent = "FINISHED"; await new Promise(r => setTimeout(r, 800));
            devOverlay.style.display = 'none'; if (isRollMode) { await clearTemp(); currentFrame = 0; updateCounterDisplay(); } else { pendingPhoto = null; } checkLeverState();
        }

        backLock.addEventListener('click', () => { const isOpen = backDoorWrapper.classList.contains('open'); if (!isOpen) { backDoorWrapper.classList.add('open'); backLock.style.transform = 'translateX(5px)'; loadAlbum(); } else { closeBackDoor(); } });
        function closeBackDoor() { backDoorWrapper.classList.remove('open'); backLock.style.transform = 'translateX(0)'; }
        
        let selectedAlbumIds = new Set(); let currentAlbumData = [];
        async function loadAlbum() {
            albumGrid.innerHTML = ''; selectedAlbumIds.clear(); currentAlbumData = await getAlbumPhotos(); currentAlbumData.sort((a,b) => b.timestamp - a.timestamp);
            if(currentAlbumData.length === 0) { albumGrid.innerHTML = '<p style="color:#555; width:100%; text-align:center; margin-top:50px; font-family:monospace;">ALBUM EMPTY</p>'; return; }
            currentAlbumData.forEach(p => {
                const div = document.createElement('div'); div.className = 'album-photo'; div.dataset.id = p.id;
                const img = document.createElement('img'); img.src = p.image;
                const seq = document.createElement('div'); seq.className = 'album-seq'; seq.textContent = `No.${p.serial}`;
                div.appendChild(img); div.appendChild(seq);
                div.onclick = (e) => { if (div.clickTimeout) { clearTimeout(div.clickTimeout); div.clickTimeout = null; showZoom(p.image); } else { div.clickTimeout = setTimeout(() => { div.clickTimeout = null; toggleSelection(div, p.id); }, 250); } };
                albumGrid.appendChild(div);
            });
        }
        
        function showZoom(imgSrc) { zoomImg.src = imgSrc; zoomOverlay.style.display = 'flex'; }
        zoomOverlay.addEventListener('click', () => { zoomOverlay.style.display = 'none'; });
        function toggleSelection(el, id) { if (selectedAlbumIds.has(id)) { selectedAlbumIds.delete(id); el.classList.remove('selected'); } else { selectedAlbumIds.add(id); el.classList.add('selected'); } }
        document.getElementById('alb-sel-all').addEventListener('click', () => { const allEls = document.querySelectorAll('.album-photo'); const allSelected = selectedAlbumIds.size === currentAlbumData.length; allEls.forEach(el => { const id = parseInt(el.dataset.id); if (allSelected) { selectedAlbumIds.delete(id); el.classList.remove('selected'); } else { selectedAlbumIds.add(id); el.classList.add('selected'); } }); });
        document.getElementById('alb-delete').addEventListener('click', async () => { if (!checkSelection()) return; if (confirm("DELETE SELECTED PHOTOS?")) { const idsToRemove = Array.from(selectedAlbumIds); await deleteFromAlbum(idsToRemove); await loadAlbum(); } });

        const exportModal = document.getElementById('export-modal'); let exportActionType = ''; 
        function checkSelection() { if (selectedAlbumIds.size === 0) { alert("SELECT PHOTOS FIRST"); return false; } return true; }
        document.getElementById('alb-download').addEventListener('click', () => { if(!checkSelection()) return; exportActionType = 'download'; exportModal.style.display = 'flex'; });
        document.getElementById('alb-share').addEventListener('click', () => { if(!checkSelection()) return; if(!navigator.share) { alert("SHARING NOT SUPPORTED"); return; } exportActionType = 'share'; exportModal.style.display = 'flex'; });
        document.getElementById('exp-cancel').addEventListener('click', () => exportModal.style.display = 'none');
        document.getElementById('exp-no-serial').addEventListener('click', () => processExport(false));
        document.getElementById('exp-with-serial').addEventListener('click', () => processExport(true));

        async function processExport(addSerial) {
            const selectedData = currentAlbumData.filter(p => selectedAlbumIds.has(p.id)); const filesToShare = [];
            for (let p of selectedData) {
                let finalDataUrl = p.image; if (addSerial) finalDataUrl = await overlaySerial(p.image, p.serial, p.style);
                const fileName = `RETRO_No${p.serial}_${Date.now()}.jpg`;
                if (exportActionType === 'download') { const link = document.createElement('a'); link.download = fileName; link.href = finalDataUrl; link.click(); await new Promise(r => setTimeout(r, 200)); } 
                else { const blob = await (await fetch(finalDataUrl)).blob(); filesToShare.push(new File([blob], fileName, { type: 'image/jpeg' })); }
            }
            if (exportActionType === 'share' && filesToShare.length > 0) { try { await navigator.share({ files: filesToShare }); } catch (e) {} }
            const idsToRemove = selectedData.map(p => p.id); await deleteFromAlbum(idsToRemove); resetToCameraUI();
        }

        function resetToCameraUI() { exportModal.style.display = 'none'; closeBackDoor(); document.getElementById('review-overlay').style.display = 'none'; pendingPhoto = null; checkLeverState(); }
        function checkOrientation() { if (window.innerHeight > window.innerWidth) { document.getElementById('orientation-lock').style.display = 'flex'; document.getElementById('camera-container').style.display = 'none'; fsPrompt.style.display = 'none'; } else { document.getElementById('orientation-lock').style.display = 'none'; if (document.fullscreenElement) { document.getElementById('camera-container').style.display = 'block'; document.getElementById('fullscreen-prompt').style.display = 'none'; resizeElements(); } else { enforceFullscreen(); } } }
        function resizeElements() { const scale = Math.min(window.innerWidth / 800, window.innerHeight / 480); document.getElementById('camera-container').style.transform = `scale(${scale})`; }
        window.addEventListener('resize', () => { checkOrientation(); resizeElements(); });

    </script>
</body>
</html>
